<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scroll-Animations Lab</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.png" />
    <link rel="stylesheet" href="/src/styles/allStyle/fonts.css">
    <link rel="stylesheet" href="/src/styles/dark-theme.css">
    <link rel="stylesheet" href="/src/styles/allStyle/oneSection-style.css">
    <link rel="stylesheet" href="/src/styles/allStyle/twoSection-style.css">
    <link rel="stylesheet" href="/src/styles/allStyle/test.style.css">
    <link rel="stylesheet" href="/src/styles/allStyle/carousel-style.css">
    <link rel="stylesheet" href="/src/styles/allStyle/image-reveal.css">
    <link rel="stylesheet" href="/src/styles/allStyle/parallax.css">
    <link rel="stylesheet" href="/src/styles/allStyle/super-scroll.css">
    <link rel="stylesheet" href="/src/styles/allStyle/progress-bar.css">
    <link rel="stylesheet" href="/src/styles/allStyle/card-stack.css">
    <link rel="stylesheet" href="/src/styles/allStyle/cascading-text-reveal.css">
    <link rel="stylesheet" href="/src/styles/allStyle/scaling-images.css">
    <link rel="stylesheet" href="./src/styles/allStyle/svg-animation.css">
    <link rel="stylesheet" href="./src/styles/allStyle/cube-3d.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="page-progress-bar"></div>
    <button class="mobile-menu-toggle">
        <i class="fas fa-bars"></i>
    </button>

    <aside class="sidebar">
        <div class="sidebar-header">
            <h1>Scroll Animations</h1>
            <p>Interactive demos and code examples</p>
        </div>
        <nav>
            <ul class="nav-links">
                <li class="nav-item">
                    <a href="#general-info" class="nav-link" data-title="Обзор технологии Scroll-Driven Animations">
                        <i class="icon fas fa-book-open"></i>
                        Обзор технологии
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#recipes-container" class="nav-link" data-title="Рецепты Scroll-Driven Animations">
                        <i class="icon fas fa-flask"></i>
                        Рецепты
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#polyfill" class="nav-link" data-title="Polyfill, ограничения и общая информация">
                        <i class="icon fas fa-info-circle"></i>
                        Polyfill, ограничения и общая информация
                    </a>
                </li>
            </ul>
        </nav>
    </aside>

    <header class="header">
        <h1>Scroll Animations</h1>
    </header>

    <main class="content-wrapper">
        <section id="general-info" class="content-section">
            <div class="section-header">
                <h2>Обзор технологии Scroll-Driven Animations</h2>
                <p>Подробное описание, ключевые концепции, области применения, плюсы и минусы.</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>Описание технологии</h3>
                    <p class="paragraf">Для управления анимацией связанной со скроллом добавлены две концепции это Scroll Timelines and View Timelines или Временная шкала (<a href="https://drafts.csswg.org/scroll-animations-1/" target="_blank" rel="noopener noreferrer">спецификация W3C</a>) прогресса прокрутки и временная шкала просмотра.</p>
                    <p class="paragraf">По умолчанию у нас есть только одна временная шкала и это временная шкала документа, но с этой спецификацией появляется еще две временных шкалы. Временная шкала прогресса прокрутки (Scroll Progress Timeline) и временная шкала просмотра (View Progress Timeline). Первая закрепляется и отслеживает прогресс прокрутки контейнера в процентах. А вторая отслеживает относительное положение элемента в его контейнере прокрутки.</p>
                    <p class="paragraf">Общее описание:<br />
                    <strong>Scroll Progress Timeline</strong> - Позволяет отслеживать прогресс прокрутки контейнера.<br />
                    <strong>View Progress Timeline</strong> - Позволяет отслеживать прогресс прокрутки конкретного элемента в нашем экране. Или в нашей зоне видимости.</p>
                    <p class="paragraf">Также это свойство позволяет нам гибко настраивать, в какой момент должна начинаться и заканчиваться анимация. Мы можем запускать анимацию только в момент пересечения объекта с нашей областью видимости или при выходе его из нее. Также можно заканчивать анимацию на середине экрана или начинать как только объект полностью вошел в область видимости.</p>

                    <h4>Scroll Progress Timeline</h4>
                    <p class="paragraf">Начнем с использования временной шкалы прогресса прокрутки:</p>
                    <div class="code-block"><pre><code class="language-css">animation: animate-it linear both; /* 'both' для удержания состояния */
animation-timeline: scroll(root block);
/* Время анимации не указывается (auto по умолчанию) */</code></pre></div>
                    <p class="paragraf">В комбинированном свойстве animation нам нужно указать название анимации (animatie-it) функцию анимации (linear), также для корректной работы полифила и показа анимации при загрузке страницы нужно указать fill-mode = both, что позволит анимации быть не прерываться, так как в таком случае после окончания анимации к элементу применяется стили для последнего кадра и у нас не будет прыгать наша анимация к началу, после того, как мы полностью. прокрутили контейнер. Обязательно нужно не указывать время анимации. Для корректной работы нужно оставить его в auto. Можно просто не указывать, так как по умолчанию он auto.</p>
                    <p class="paragraf">Далее мы создаем временную школу прокрутки, относительно которой и будет происходить анимация. Для этого пользуемся свойством animation-timeline и как значение указываем функцию scroll() которая принимает два значения. Первое это контейнер, который используем для отслеживания прокрутки. Тут может быть 3 значения:</p>
                    <ul class="ul">
                        <li class="li"><code>nearest</code>: использует контейнер прокрутки ближайшего предка (по умолчанию).</li>
                        <li class="li"><code>root</code>: использует область просмотра документа в качестве контейнера прокрутки.</li>
                        <li class="li"><code>self</code>: использует сам элемент в качестве контейнера прокрутки.</li>
                    </ul>
                    <p class="paragraf">И второе это ось. Тут может быть 4 значения:</p>
                    <ul class="ul">
                        <li class="li"><code>block</code>: использует меру прогресса вдоль оси блока контейнера прокрутки (по умолчанию).</li>
                        <li class="li"><code>inline</code>: использует меру прогресса вдоль встроенной оси контейнера прокрутки.</li>
                        <li class="li"><code>y</code>: использует меру прогресса по оси y контейнера прокрутки.</li>
                        <li class="li"><code>x</code>: использует меру прогресса по оси x контейнера прокрутки.</li>
                    </ul>
                    <p class="paragraf">Так в примере мы привязались к оси прокрутки нашего документа и используем его основную ось, то есть сверху вниз.</p>
                    <p class="paragraf">Также мы можем использовать именованную временную шкалу прогресса прокрутки. Что позволит нам привязать ее к любому элементу и выбрать ось. После чего указать в другом элементе для выполнения анимации.</p>
                    <div class="code-block"><pre><code class="language-css">.scroller {
  scroll-timeline-name: --my-scroller;
  scroll-timeline-axis:
}

.scroller .subject {
  animation: animate-it linear both;
  animation-timeline: --my-scroller;
}</code></pre></div>

                    <h4>View Progress Timeline</h4>
                    <p class="paragraf">Далее рассмотрим возможность работы с временной шкалой просмотра:</p>
                    <div class="code-block"><pre><code class="language-css">@keyframes reveal {
  from { opacity: 0; }
  to { opacity: 1; }
}

img {
  animation: reveal linear both;
  animation-timeline: view(); /* Ось по умолчанию 'block' */
}</code></pre></div>
                    <p class="paragraf">Значения для свойства animation указываются также, как и для scroll timeline. Но есть отличие в указании значений для свойства animation-timeline. Для задания временной шкалы просмотра нужно использовать функцию view() которая принимает 2 аргумента. Также как и в первом свойстве есть аргумент для задания оси прокрутки. По умолчанию это block.</p>
                    <p class="paragraf">Второй аргумент отвечает за смещение анимации. Может принимать следующие значения:</p>
                    <ul class="ul">
                        <li class="li"><code>cover</code>: представляет полный диапазон временной шкалы просмотра.</li>
                        <li class="li"><code>entry</code>: представляет диапазон, в течение которого основное поле входит в диапазон видимости прогресса просмотра.</li>
                        <li class="li"><code>exit</code>: представляет диапазон, в течение которого основной блок выходит из диапазона видимости прогресса просмотра.</li>
                        <li class="li"><code>entry-crossing</code>: представляет диапазон, в течение которого основной блок пересекает край конечной границы.</li>
                        <li class="li"><code>exit-crossing</code>: представляет диапазон, в течение которого основной блок пересекает край начальной границы.</li>
                        <li class="li"><code>contain</code>: представляет диапазон, в течение которого основной блок либо полностью содержится, либо полностью покрывает диапазон видимости прогресса просмотра в области прокрутки. Это зависит от того, выше или короче объект скроллера. (Анимация начинает проигрываться, только когда объект полностью появился в поле зрения)</li>
                    </ul>
                    <p class="paragraf">Чтобы установить правила для начала и окончания анимации нужно использовать свойство <code>animation-range</code>. Где мы можем указать любое из вышеперечисленных значений и процент, на сколько оно выполняется. Так для начала анимации при входе в область видимости и окончании, когда объект полностью в нее войдет нужно использовать такие значения:</p>
                    <div class="code-block"><pre><code class="language-css">animation-range: entry 0% entry 100%;</code></pre></div>
                    <p class="paragraf">Чтобы лучше разобраться в этих свойствах есть инструмент конструктор, в котором вы можете попробовать их все: <a href="https://scroll-driven-animations.style/tools/view-timeline/ranges" target="_blank" rel="noopener noreferrer">View Timeline Ranges Visualizer</a>.</p>
                    <p class="paragraf">Нужно обратить внимание, что эти диапазоны получены из не преобразованного основного блока субъекта. Это означает, что такие преобразования, как scale и translate, не учитываются при определении диапазонов. Что позволяет нам использовать смещение и увеличения для создания анимации.</p>
                    <p class="paragraf">Аналогично scroll timeline мы также можем создавать именованные временные шкалы просмотра, то есть view-timeline. И применять к ним те же значения, а после передавать в свойство animation-timeline.</p>
                    <p class="paragraf">Например, вот так:</p>
                    <div class="code-block"><pre><code class="language-css">.revealing-image {
  view-timeline-name: --revealing-image;
  view-timeline-axis: block;

  animation: reveal linear both;
  animation-timeline: --revealing-image;
  animation-range: entry 25% cover 50%;
}</code></pre></div>
                </div>

                <div class="docs-block">
                    <h3>Плюсы и минусы технологии</h3>
                    <h4>Плюсы:</h4>
                    <ul class="ul">
                        <li class="li"><strong>Производительность:</strong> Технология не использует основной поток выполнения javascript, что позволяет работать плавно и не мешать вычислениям в основном потоке.</li>
                        <li class="li"><strong>Лаконичность:</strong> Многие популярные анимации можно сделать в несколько строк кода и не нужно ничего придумывать.</li>
                        <li class="li"><strong>Гибкость:</strong> Можно очень гибко настроить позицию для начала выполнения и окончания анимации.</li>
                        <li class="li"><strong>Простота в использовании:</strong> Здесь все работает как обычные css анимации, поэтому ничего не нужно изучать дополнительно.</li>
                    </ul>
                    <h4>Минусы:</h4>
                    <ul class="ul">
                        <li class="li"><strong>Не работает нативно в safari:</strong> Сейчас нет поддержки safari, но есть polyfill, который должен решать эту проблему, но с его использованием тоже есть особенности, о которых поговорим далее.</li>
                        <li class="li"><strong>Мало примеров, документации и решения разных проблем:</strong> Есть документация в chrome и еще вот этот сайт <a href="https://scroll-driven-animations.style/" target="_blank" rel="noopener noreferrer">https://scroll-driven-animations.style/</a>. Кроме этого никакой информации связанной с технологией нет. И решать разные проблемы связанные с разработкой на этой технологии придется вам самим.</li>
                    </ul>
                </div>

                <div class="docs-block">
                    <h3>Ссылки на источники</h3>
                    <ul class="ul">
                        <li class="li"><a href="https://scroll-driven-animations.style/" target="_blank" rel="noopener noreferrer">scroll-driven-animations.style</a> - Сайт с примерами, ссылками на другие ресурсы и конструктором для тестирования анимаций. Вся информация на английском. Нет подробного описания технологии. А также моментов работы с NextJS и polyfill.</li>
                        <li class="li"><a href="https://habr.com/ru/companies/skillfactory/articles/587792/" target="_blank" rel="noopener noreferrer">Habr: Skillfactory</a> - Перевод части документации. Рассматривают использование анимации при помощи JS, а у нас идет повествовании о css.</li>
                        <li class="li"><a href="https://habr.com/ru/articles/749794/" target="_blank" rel="noopener noreferrer">Habr: Сравнение производительности</a> - Перевод статьи, где происходит сравнение производительности с новым API на CSS и JS против старых анимаций на JS. Нет подробного описания работы с технологиями и особенности работы с nextJS. Также в сравнении производительности используют только один эффект.</li>
                        <li class="li"><a href="https://developer.chrome.com/docs/css-ui/scroll-driven-animations" target="_blank" rel="noopener noreferrer">Chrome Developers</a> - Основная документация с теорией того, как все работает и примерами. Эта документация на английском.Нет особенностей работы с polyfill и NextJS.</li>
                    </ul>
                </div>

                <div class="docs-block">
                    <h3>Важность <code>overflow</code> и динамическое управление</h3>
                    <p class="paragraf">При работе с Scroll-Driven Animations крайне важно обращать внимание на свойство <code>overflow</code> у родительских элементов. Если у родителя установлено значение <code>hidden</code>, <code>auto</code> или <code>scroll</code>, это может создать новый контекст форматирования и новый "scrollport" (область прокрутки), отличный от ожидаемого (например, viewport документа). Это, в свою очередь, может помешать корректной работе <code>animation-timeline: view()</code>, так как элемент может не считаться "видимым" относительно той области прокрутки, к которой привязана его анимация.</p>
                    <p class="paragraf"><strong>Симптомы проблемы:</strong> Анимация не запускается, когда элемент появляется на экране, или ведет себя непредсказуемо. Часто это происходит потому, что родительский контейнер с "обрезающим" <code>overflow</code> не позволяет правильно рассчитать пересечение элемента с областью видимости, которую отслеживает <code>view()</code>.</p>
                    <p class="paragraf">В данном проекте вы можете заметить, что для некоторых демонстрационных вкладок (например, "Горизонтальный скролл", "Параллакс", "SVG анимация") основному контейнеру содержимого (<code>.content-wrapper</code>) с помощью JavaScript динамически устанавливается <code>overflow: auto</code>. Это необходимо для корректной работы их собственных механизмов прокрутки. Для других вкладок, где анимации напрямую зависят от видимости в главном окне прокрутки страницы (например, "Масштабирование изображений"), этому же контейнеру устанавливается <code>overflow: visible</code>, чтобы избежать конфликтов и обеспечить правильное срабатывание <code>view()</code> таймлайнов.</p>
                    <p class="paragraf">Будьте внимательны и при отладке всегда проверяйте значения <code>overflow</code> у всех родительских элементов анимируемого компонента, если сталкиваетесь с проблемами в работе Scroll-Driven Animations.</p>
                </div>
            </div>
        </section>

        <section id="recipes-container" class="content-section">
            <div class="section-header">
                <h2>Рецепты Scroll-Driven Animations</h2>
                <p>Коллекция готовых примеров и техник.</p>
            </div>
            <div class="section-body">
                <nav class="recipes-nav">
                    <ul class="recipes-nav-links">
                        <li><a href="#horizontal-scroll" class="recipe-nav-link" data-title="Горизонтальный скролл">Горизонтальный скролл</a></li>
                        <li><a href="#carousel" class="recipe-nav-link" data-title="Карусель с маркерами">Карусель</a></li>
                        <li><a href="#reveal" class="recipe-nav-link" data-title="Появление изображения">Появление изображения</a></li>
                        <li><a href="#parallax" class="recipe-nav-link" data-title="Параллакс эффект">Параллакс</a></li>
                        <li><a href="#svg-animation" class="recipe-nav-link" data-title="SVG Анимация">SVG Анимация</a></li>
                        <li><a href="#progress-bar" class="recipe-nav-link" data-title="Индикатор прогресса">Индикатор прогресса</a></li>
                        <li><a href="#card-stack" class="recipe-nav-link" data-title="Карточки (Card Stack)">Стопка Карточек</a></li>
                        <li><a href="#cascading-text" class="recipe-nav-link" data-title="Каскадное появление текста">Каскадное появление текста</a></li>
                        <li><a href="#scaling-images" class="recipe-nav-link" data-title="Масштабирование изображений">Масштабирование изображений</a></li>
                        <li><a href="#cube-3d" class="recipe-nav-link" data-title="3D Куб">3D Куб</a></li>
                    </ul>
                </nav>
            </div>
        </section>
        <section id="horizontal-scroll" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Горизонтальный скролл при вертикальной прокрутке</h2>
                <p>Создание горизонтальной анимации, управляемой вертикальным скроллом страницы</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Для создания эффекта горизонтального скролла при вертикальной прокрутке, мы используем элемент, который "прилипает" к верхней части экрана, в то время как его содержимое двигается горизонтально.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;section class="sectionPin"&gt;
  &lt;div class="pin-wrap-sticky"&gt;
    &lt;div class="pin-wrap"&gt;
      &lt;div class="q"&gt;&lt;/div&gt;
      &lt;div class="content"&gt;
        &lt;h1 class="text"&gt;Scroll-driven Animations&lt;/h1&gt;
        &lt;p class="text-i"&gt;created by &lt;br/&gt; Author Name&lt;/p&gt;
      &lt;/div&gt;       
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/section&gt;</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>CSS Анимация</h3>
                    <p class="paragraf">Ключевые моменты в CSS: создание именованной временной шкалы просмотра (view-timeline-name), sticky-позиционирование и анимация transform с опорой на скролл. Ширина внутреннего контейнера (<code>.pin-wrap</code>) должна быть достаточной, чтобы вместить всё горизонтально прокручиваемое содержимое (в примере <code>179vmax</code>, но это значение зависит от вашего контента).</p>
                    <div class="code-block">
                        <pre><code class="language-css">@keyframes move {
  to {
    transform: translateX(calc(-100% + 100vw));
  }
}

.sectionPin {
  height: 300vh;
  overflow: visible;
  view-timeline-name: --section-pin-tl; /* Используется для привязки анимации */
  view-timeline-axis: block; /* Отслеживание по вертикальной оси */
}

.pin-wrap-sticky {
  height: 100vh;
  width: 100vw;
  position: sticky;
  top: 0;
  overflow-x: hidden;
}

.pin-wrap {
  height: 100vh;
  width: 179vmax;
  will-change: transform;
  animation: linear move forwards;
  animation-timeline: --section-pin-tl;
  animation-range: contain 0% contain 100%;
}</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Вариант с изображениями</h3>
                    <p class="paragraf">Подобный эффект можно применить и к галерее изображений.</p>
                    <div class="example-container tall-example">
                        <section class="test">
                            <div class="sticky-pin">
                                <div class="wrap-pin">
                                    <div class="q"></div>
                                    <div class="container">
                                        <img class="pin" src="https://img.freepik.com/free-photo/beautiful-mountain-forest-landscape_23-2149063036.jpg?size=626&ext=jpg" alt="Mountain Forest">
                                        <img class="pin" src="https://img.freepik.com/free-photo/mountainous-nature-landscape-with-river_23-2150705792.jpg?size=626&ext=jpg" alt="Mountain River">
                                        <img class="pin" src="https://img.freepik.com/free-photo/assortment-of-colored-plant-leaves_23-2149337900.jpg?size=626&ext=jpg" alt="Colored Leaves">
                                        <img class="pin" src="https://img.freepik.com/free-photo/beautiful-palm-tree-in-vivid-colors_23-2151591807.jpg?size=626&ext=jpg" alt="Palm Tree">
                                        <img class="pin" src="https://img.freepik.com/premium-photo/guy-on-the-edge-of-the-prelude-to-preikestolen-norway_7509-960.jpg?size=626&ext=jpg&ga=GA1.1.1818441046.1720137018&semt=ais_user" alt="Preikestolen">
                                    </div>
                                </div>
                            </div>
                        </section>
                    </div>
                </div>
            </div>
        </section>

        <section id="carousel" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Карусель с маркерами</h2>
                <p>Горизонтальная карусель изображений с синхронизированными маркерами</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Карусель состоит из двух основных компонентов: контейнера с изображениями и маркеров, которые указывают текущее положение.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;div data-component="carousel"&gt;
  &lt;ul class="entries" tabindex="0"&gt;
    &lt;li class="l"&gt;&lt;a name="carousel_01"&gt;&lt;img class="slide" src="..." alt=""&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;!-- Другие слайды --&gt;
  &lt;/ul&gt;
  &lt;ul class="markers"&gt;
    &lt;li class="Li"&gt;&lt;a href="#carousel_01"&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;!-- Другие маркеры --&gt;
  &lt;/ul&gt;
&lt;/div&gt;</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>CSS Реализация</h3>
                    <p class="paragraf">Ключевой момент - использование scroll-timeline для синхронизации маркеров с прокруткой контента.</p>
                    <div class="code-block">
                        <pre><code class="language-css">/* Определяем ключ-кадры для активного состояния маркера */
@keyframes activate-marker { 
  to { 
    background-color: var(--accent-primary); 
    transform: scale(1.2); 
    opacity: 1;
  }
}

[data-component="carousel"] {
  /* Создаем именованную область видимости для таймлайна */
  timeline-scope: --carousel;
}

.entries {
  /* Привязываем таймлайн к горизонтальной прокрутке списка .entries */
  scroll-timeline: --carousel x; 
}

.markers a {
  /* Анимация для маркеров, привязанная к таймлайну --carousel */
  animation: activate-marker linear forwards;
  animation-timeline: --carousel;
  animation-fill-mode: both; /* 'both' не требуется с forwards, но оставлено для ясности */
  
  /* Динамический расчет диапазона анимации для каждого маркера */
  /* Анимация активна, когда соответствующий слайд находится в видимой части */
  animation-range-start: calc((var(--i) - 1) * 25%);
  animation-range-end: calc(var(--i) * 25%);
}

/* Пример задания переменной --i для каждого маркера (обычно делается в HTML или CSS) */
/* .markers li:nth-child(1) a { --i: 1; } */
/* .markers li:nth-child(2) a { --i: 2; } */
/* ... и так далее для всех маркеров */

/* Необходимые стили для задания переменной --i */
.markers li:nth-child(1) a { --i: 1; }
.markers li:nth-child(2) a { --i: 2; }
.markers li:nth-child(3) a { --i: 3; }
.markers li:nth-child(4) a { --i: 4; }
/* Добавьте больше правил, если у вас больше слайдов */
</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите карусель и наблюдайте, как маркеры активируются в соответствии с положением контента.</p>
                    <div class="example-container">
                        <section class="cont">
                            <div data-component="carousel">
                                <ul class="entries" tabindex="0">
                                    <li class="l"><a name="carousel_01"><img class="slide" src="https://img.freepik.com/premium-photo/scenic-view-of-rocks-in-sea-against-clear-sky_1048944-19066138.jpg?size=626&ext=jpg&ga=GA1.1.1143220769.1720183557&semt=ais_user" alt="Rocks in sea" draggable="false"></a></li>
                                    <li class="l"><a name="carousel_02"><img class="slide" src="https://img.freepik.com/premium-photo/cluster-of-purple-and-blue-leaves_118124-302144.jpg?size=626&ext=jpg&ga=GA1.1.1143220769.1720183557&semt=ais_user" alt="Purple leaves" draggable="false"></a></li>
                                    <li class="l"><a name="carousel_03"><img class="slide" src="https://img.freepik.com/free-photo/beautiful-scenery-of-green-trees-near-the-body-of-water-over-high-mountains_181624-18193.jpg?size=626&ext=jpg&ga=GA1.1.1143220769.1720183557&semt=ais_user" alt="Green trees" draggable="false"></a></li>
                                    <li class="l"><a name="carousel_04"><img class="slide" src="https://img.freepik.com/free-photo/mountainous-nature-landscape-with-river_23-2150705796.jpg?size=626&ext=jpg&ga=GA1.1.1143220769.1720183557&semt=ais_user" alt="Mountain river" draggable="false"></a></li>
                                </ul>
                                <ul class="markers">
                                    <li class="Li"><a href="#carousel_01"></a></li>
                                    <li class="Li"><a href="#carousel_02"></a></li>
                                    <li class="Li"><a href="#carousel_03"></a></li>
                                    <li class="Li"><a href="#carousel_04"></a></li>
                                </ul>
                            </div>
                        </section>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: Reveal Image -->
        <section id="reveal" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Появление изображения</h2>
                <p>Эффект появления изображений при скролле страницы</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>Принцип работы</h3>
                    <p class="paragraf">Эта техника использует view timeline для анимации появления изображения при его попадании в область видимости.</p>
                    <div class="code-block">
                        <pre><code class="language-css">@keyframes reveal {
  from {
    opacity: 0;
    transform: translateY(100px);
  }
  to {
    opacity: 1;
    transform: translateY(0px);
  }
}

.revealing-image {
  /* Задаем имя для view-timeline и ось отслеживания */
  view-timeline-name: --revealing-image;
  view-timeline-axis: block;

  /* Применяем анимацию */
  animation: linear reveal both;
  /* Привязываем анимацию к созданному view-timeline */
  animation-timeline: --revealing-image;
  /* Диапазон анимации: начинается, когда элемент входит на 0% в зону видимости,
     и полностью виден (cover) на 50% этой зоны */
  animation-range: entry 0% cover 50%;
}</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите вниз, чтобы увидеть, как изображения появляются, когда входят в область видимости.</p>
                    <div class="example-container">
                        <section class="reveal">
                            <div class="title center" style="text-align:center; margin-bottom:1em;">
                                <h3 class="text-two" style="margin-bottom:0.5em;">Изображения с эффектом появления</h3>
                            </div>
                            <img class="image revealing-image" src="./src/img/reveal/1.jpg" alt="Anime girl 1">
                            <img class="image revealing-image" src="./src/img/reveal/2.jpg" alt="Anime girl 2">
                        </section>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 4: Parallax -->
        <section id="parallax" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Параллакс эффект</h2>
                <p>Создание эффекта параллакса при прокрутке изображений</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>HTML и CSS реализация</h3>
                    <p class="paragraf">При горизонтальной прокрутке слайдов, изображения внутри них двигаются с разной скоростью, создавая эффект глубины.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;ul class="slides"&gt;
  &lt;li class="slide"&gt;&lt;img src="..." alt=""&gt;&lt;/li&gt;
  &lt;!-- Другие слайды --&gt;
&lt;/ul&gt;</code></pre>
                    </div>
                    <div class="code-block">
                        <pre><code class="language-css">/* Базовые стили для контейнера и слайдов */
.slides {
  list-style: none;
  overflow-x: scroll; /* Важно для view(x) */
  overflow-y: hidden;
  white-space: nowrap;
}

.slide {
  display: inline-block;
  width: 600px;
  height: 99vh;
  position: relative;
  overflow: clip;
}

.slide &gt; img {
  object-fit: cover;
  object-position: 100% 0;
  display: block;
  width: 100%;
  height: 100%;
  position: absolute;
  right: 0;
  animation: adjust-image linear both; /* 'both' удерживает состояние анимации */
  animation-timeline: view(x); /* Анимация привязана к горизонтальной прокрутке родительского .slide */
}

@keyframes adjust-image {
  0% {
    object-position: 100% 0;
  }
  100% {
    object-position: 0 0;
  }
}
</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите галерею горизонтально и наблюдайте за эффектом параллакса на изображениях.</p>
                    <div class="example-container">
                        <ul class="slides">
                            <li class="slide"><img src="./src/img/parallax/1.jpg" alt="Parallax 1"></li>
                            <li class="slide"><img src="./src/img/parallax/2.jpg" alt="Parallax 2"></li>
                            <li class="slide"><img src="./src/img/parallax/3.jpg" alt="Parallax 3"></li>
                            <li class="slide"><img src="./src/img/parallax/4.jpg" alt="Parallax 4"></li>
                            <li class="slide"><img src="./src/img/parallax/5.jpg" alt="Parallax 5"></li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <section id="svg-animation" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>SVG Анимация</h2>
                <p>Анимация SVG элементов при прокрутке страницы</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>SVG и CSS</h3>
                    <p class="paragraf">SVG элементы могут быть анимированы с помощью CSS и привязаны к прокрутке страницы.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;section class="super-scroll"&gt;
  &lt;div class="super-svg"&gt;
    &lt;svg viewBox="0 0 100 100" class="super-svg-1"&gt;
      &lt;circle cx="50" cy="50" r="40" /&gt;
    &lt;/svg&gt;
    &lt;svg viewBox="0 0 800 120" class="super-svg-text"&gt;
      &lt;text x="50%" y="50%" ...&gt;Scroll-Driven Animation&lt;/text&gt;
    &lt;/svg&gt;
    &lt;svg viewBox="0 0 100 100" class="super-svg-2"&gt;
      &lt;rect x="10" y="10" width="80" height="80" rx="10"/&gt;
    &lt;/svg&gt;
  &lt;/div&gt;
&lt;/section&gt;</code></pre>
                    </div>
                    <div class="code-block">
                        <pre><code class="language-css">.super-scroll {
  height: 200vh;
  position: relative;
  view-timeline-name: --super-scroll-tl;
  view-timeline-axis: block;
  overflow: visible;
  padding-inline: 2vw;
}

.super-svg {
  position: sticky;
  top: 0;
  width: 100%;
  height: 60vh;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8vw;
  z-index: 1;
  pointer-events: none;
  background: none;
}

.super-svg-1 {
  width: 28vw;
  height: 28vw;
  min-width: 150px;
  min-height: 150px;
  stroke: #3a86ff;
  stroke-width: 7;
  fill: none;
  stroke-linecap: round;
  stroke-dasharray: 251;
  stroke-dashoffset: 251;
  animation: circle-rotate linear forwards;
  animation-timeline: --super-scroll-tl;
  animation-range: contain 0% contain 100%;
}

@keyframes circle-rotate {
  0% {
    stroke-dashoffset: 251;
    transform: rotate(0deg);
  }
  100% {
    stroke-dashoffset: 0;
    transform: rotate(360deg);
  }
}

.super-svg-text {
  width: 60vw;
  height: 120px;
}

.super-svg-text text {
  stroke: url(#superTextGradient);
  stroke-width: 3;
  fill: none;
  font-size: 64px;
  font-family: 'Montserrat', Arial, sans-serif;
  text-anchor: middle;
  dominant-baseline: middle;
  stroke-dasharray: 900;
  stroke-dashoffset: 900;
  animation: text-draw linear forwards;
  animation-timeline: --super-scroll-tl;
  animation-range: contain 0% contain 100%;
}

@keyframes text-draw {
  0% {
    stroke-dashoffset: 900;
  }
  100% {
    stroke-dashoffset: 0;
  }
}

.super-svg-2 {
  width: 22vw;
  height: 22vw;
  min-width: 120px;
  min-height: 120px;
  stroke: #8338ec;
  stroke-width: 6;
  fill: none;
  stroke-linecap: square;
  stroke-dasharray: 320;
  stroke-dashoffset: 320;
  animation: rect-rotate linear forwards;
  animation-timeline: --super-scroll-tl;
  animation-range: contain 0% contain 100%;
}

@keyframes rect-rotate {
  0% {
    stroke-dashoffset: 320;
    transform: rotate(0deg);
  }
  100% {
    stroke-dashoffset: 0;
    transform: rotate(-360deg);
  }
}

/* Не забудьте определить градиент, если используете его для текста */
/*
<svg>
  <defs>
    <linearGradient id="superTextGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" stop-color="#3a86ff" stop-opacity="0.8"/>
      <stop offset="60%" stop-color="#8338ec" stop-opacity="0.8"/>
      <stop offset="100%" stop-color="#fff" stop-opacity="0.7"/>
    </linearGradient>
  </defs>
</svg>
*/
</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите страницу вниз, чтобы увидеть анимацию SVG элементов.</p>
                    <div class="example-container tall-example">
                        <section class="super-scroll">
                            <div class="super-svg">
                                <svg viewBox="0 0 100 100" class="super-svg-1"><circle cx="50" cy="50" r="40" /></svg>
                                <svg viewBox="0 0 800 120" class="super-svg-text" width="60vw" height="120">
                                    <defs>
                                        <linearGradient id="superTextGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" stop-color="#3a86ff" stop-opacity="0.8"/>
                                            <stop offset="60%" stop-color="#8338ec" stop-opacity="0.8"/>
                                            <stop offset="100%" stop-color="#fff" stop-opacity="0.7"/>
                                        </linearGradient>
                                    </defs>
                                    <text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle" font-size="64" font-family="'Montserrat', Arial, sans-serif" fill="none" stroke="url(#superTextGradient)" stroke-width="3" stroke-linecap="round">Scroll-Driven Animation</text>
                                </svg>
                                <svg viewBox="0 0 100 100" class="super-svg-2"><rect x="10" y="10" width="80" height="80" rx="10"/></svg>
                            </div>
                        </section>
                    </div>
                </div>
            </div>
        </section>

        <section id="progress-bar" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Индикатор прогресса страницы</h2>
                <p>Создание индикатора, показывающего прогресс прокрутки всей страницы.</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Для индикатора прогресса нам нужен всего один простой элемент <code>&lt;div&gt;</code>, который будет позиционирован вверху страницы. Этот элемент должен быть прямым потомком <code>&lt;body&gt;</code> для корректной работы с <code>scroll(root block)</code>.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;body&gt;
  &lt;div class="page-progress-bar"&gt;&lt;/div&gt;
  
  &lt;!-- Остальное содержимое страницы: сайдбар, хедер, контент --&gt;
  &lt;aside class="sidebar"&gt;...&lt;/aside&gt;
  &lt;header class="header"&gt;...&lt;/header&gt;
  &lt;main class="content-wrapper"&gt;...&lt;/main&gt;
&lt;/body&gt;</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>CSS Анимация</h3>
                    <p class="paragraf">Ключевые моменты в CSS: фиксированное позиционирование (<code>position: fixed</code>) вверху экрана, начальная ширина 0% и анимация, привязанная к временной шкале прокрутки всего документа (<code>animation-timeline: scroll(root block)</code>). Анимация <code>fill-progress</code> изменяет свойство <code>width</code> элемента от 0% до 100% по мере прокрутки пользователем содержимого страницы.</p>
                    <div class="code-block">
                        <pre><code class="language-css">.page-progress-bar {
  position: fixed;
  top: 0;
  left: 0;
  width: 0;
  height: 5px;
  background-color: var(--accent-primary);
  z-index: 1000;
  
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.3s ease, visibility 0s ease 0.3s;

  /* Применяем анимацию заполнения */
  animation: fill-progress linear forwards;
  /* 'forwards' удерживает конечное состояние анимации (width: 100%) */
  
  /* Привязываем анимацию к прокрутке всего документа по вертикальной оси */
  animation-timeline: scroll(root block); 
}

.page-progress-bar.progress-bar-active-on-tab {
  visibility: visible;
  opacity: 1;
  transition: opacity 0.3s ease, visibility 0s ease 0s;
}

@keyframes fill-progress {
  from {
    width: 0%;
  }
  to {
    width: 100%;
  }
}</code></pre>
                    </div>
                    <p class="paragraf"><code>scroll(root block)</code> указывает, что временная шкала анимации определяется прокруткой корневого элемента документа (обычно <code>&lt;html&gt;</code>) по его блочной (вертикальной) оси.</p>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите эту страницу вверх и вниз, чтобы увидеть, как индикатор прогресса в самой верхней части окна браузера заполняется. Для наглядности ниже добавлен блок с большой высотой, чтобы обеспечить достаточную область для прокрутки.</p>
                    <div class="example-container" style="height: 150vh; background-color: var(--bg-tertiary); padding: 2rem; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
                        <p style="font-size: 1.5rem; color: var(--text-secondary); margin-bottom: 1rem;">Прокручивайте эту область, чтобы увидеть эффект индикатора прогресса страницы.</p>
                        <p style="font-size: 1rem; color: var(--text-tertiary);">Чем больше вы прокручиваете, тем больше заполняется полоса вверху экрана.</p>
                        <div style="margin-top: 2rem; font-size: 5rem; opacity: 0.2;"><i class="fas fa-arrow-down"></i></div>
                    </div>
                </div>
            </div>
        </section>

        <section id="polyfill" class="content-section">
            <div class="section-header">
                <h2>Polyfill, поддержка браузерами и производительность</h2>
                <p>Информация о polyfill для Scroll-Driven Animations, его работе, ограничениях, поддержке в браузерах, вопросах производительности и интеграции с NextJS.</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>Поддержка браузерами и Polyfill</h3>
                    <p class="paragraf">CSS scroll-driven animations - относительно новая технология. В Firefox её нужно включать вручную (флаг <code>layout.css.scroll-driven-animations.enabled</code> в <code>about:config</code>), а Safari долгое время не поддерживал нативно и требует polyfill.</p>
                    <p class="paragraf">Для улучшения кроссбраузерности можно использовать polyfill:</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;!-- Подключение polyfill --&gt;
&lt;script src="https://flackr.github.io/scroll-timeline/dist/scroll-timeline.js"&gt;&lt;/script&gt;</code></pre>
                    </div>
                    <p class="paragraf">К сожалению, данный метод создания анимаций имеет свои недостатки. В частности, в браузере Firefox требуется отдельное включение этой функции в настройках CSS. Safari не поддерживает указанные свойства. Есть полифилл, который поможет решить проблему совместимости, однако у него есть свои ограничения. Отсутствие документации затрудняет работу, поскольку информация о возможных проблемах может быть доступна только в процессе разработки или в разделе проблем на GitHub.</p>
                </div>

                <div class="docs-block">
                    <h3>Как работает Polyfill?</h3>
                    <p class="paragraf">Подключение осуществляется путем добавления JavaScript-скрипта на вашу страницу. Скрипт можно скачать или подключить через ссылку. Все свойства анимации, связанные с <code>animation-timeline</code>, извлекаются из CSS и переопределяются с помощью JavaScript в соответствии с требованиями, описанными в спецификации для этих свойств: <a href="https://drafts.csswg.org/scroll-animations-1/" target="_blank" rel="noopener noreferrer">W3C Scroll Animations Level 1</a>.</p>
                    <p class="paragraf">Полифил сканирует CSS правила и переопределяет свойства, связанные с animation-timeline, используя JavaScript.</p>
                    <img class="img image-center" src="/src/img/polyfill/1.png" alt="CSS Parsing Concept">
                    <img class="img image-center" src="/src/img/polyfill/2.png" alt="Script Tag Example">
                </div>

                <div class="docs-block">
                    <h3>Ограничения Polyfill</h3>
                    <p class="paragraf"><strong>Проблема с подключением CSS файлов по ссылкам асинхронно:</strong> Так как полифил получает CSS при загрузке. И если он загрузится до загрузки CSS загружаемых асинхронно, то он не сможет их спарсить.</p>
                    <p class="paragraf"><strong>Проблема с подключением этого полифилла асинхронно:</strong> Так как изначально у нас существует временная шкала документа, которая обычно и используется при анимациях, то при загрузке документа эти анимации сразу начинают выполнятся. А полифилл работает таким образом, что он ловит анимации перед тем, как они исполнятся. И не успевая загрузиться все анимации уже "сыграли" и он не может их обработать.</p>
                    <p class="paragraf">Существует проблема при подключении CSS-файлов асинхронно. Полифилл получает CSS во время загрузки страницы, и если он загружается до того, как асинхронно загружаемые CSS-файлы будут доступны, полифилл не сможет их корректно обработать.</p>
                    <p class="paragraf">Также возникают трудности при асинхронной загрузке самого полифилла. Поскольку на момент загрузки документа уже существует временная шкала, используемая для анимаций, анимации начинают выполняться сразу. Полифилл перехватывает анимации до их выполнения, но если он не успевает загрузиться во время, анимации уже могут завершиться, и полифилл не сможет их корректно обработать.</p>
                    <img class="img image-center" src="/src/img/polyfill/3.png" alt="Async Loading Issue">
                    <p class="paragraf"><strong>Попытки решения проблемы с асинхронной загрузкой:</strong> Чтобы анимация не закончилась до загрузки нужно отображать компоненты или добавлять стили с анимацией только после загрузки самого полифила.</p>
                    <p class="paragraf">Дополнительные ограничения из оригинального файла:</p>
                    <ul class="ul">
                        <li class="li"><strong>Отсутствие документации:</strong> Многие нюансы выясняются только на практике.</li>
                        <li class="li"><strong>Производительность:</strong> JavaScript-эмуляция может быть менее эффективной.</li>
                    </ul>
                    <p class="paragraf">Несмотря на ограничения, polyfill позволяет использовать scroll-driven animations во всех современных браузерах.</p>
                </div>

                <div class="docs-block">
                    <h3>Работа с NextJS и Polyfill</h3>
                    <h4>Проблемы работы с NextJS:</h4>
                    <p class="paragraf">Работа с nextJS. Все тесты проводились на nextJS версии 14.2.5, app router. Был подключен полифил в layout с помощью ссылки на скрипт, из документации к полифилу. Далее тестируем разные анимации: Я взял 4 эффекта, это carousel, horizontal scroll, progress и reveal.</p>
                    <p class="paragraf"><strong>Результаты (Chrome Desktop):</strong> Все 4 эффекта отлично работают на компьютере в браузере chrome.</p>
                    <p class="paragraf"><strong>Результаты (Chrome Mobile):</strong> На телефоне в chrome работают horizontal scroll, progress, reveal.</p>
                    <p class="paragraf"><strong>Результаты (BrowserStack Safari 17.3):</strong> В browserStack на safari 17.3 работают carousel, horizontal scroll (есть баг), progress и reveal.</p>
                    <p class="paragraf">Тестирование на версии "next": "^13.5.2" page router. Подключение полифила аналогичное.</p>
                    <p class="paragraf"><strong>Результаты (Chrome Desktop):</strong> Все 4 эффекта отлично работают на компьютере в браузере chrome.</p>
                    <p class="paragraf"><strong>Результаты (Chrome Mobile):</strong> На телефоне в chrome работают horizontal scroll, progress, reveal.</p>
                    <p class="paragraf"><strong>Результаты (BrowserStack Safari 17.3):</strong> В browserStack на safari 17.3 работают carousel, horizontal scroll (есть баг), progress и reveal.</p>
                    <p class="paragraf">Также был проверен firefox 127 все отлично работает.</p>
                </div>
            </div>
        </section>

        <section id="card-stack" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Эффект "Стопка Карточек" при скролле</h2>
                <p>Создание анимации, где карточки последовательно "налипают" друг на друга при прокрутке.</p>
            </div>
            <div class="section-body">

                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Структура состоит из общего контейнера (<code>.card-stack-example-area</code>), который обеспечивает необходимую высоту для прокрутки, и самих карточек (<code>.card-stack-card</code>), каждая из которых будет анимироваться и "прилипать".</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;div class="card-stack-example-area"&gt;
  &lt;div class="card-stack-card card-1"&gt;
    &lt;h4&gt;Карточка 1&lt;/h4&gt;
    &lt;p&gt;Содержимое первой карточки...&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="card-stack-card card-2"&gt;
    &lt;h4&gt;Карточка 2&lt;/h4&gt;
    &lt;p&gt;Содержимое второй карточки...&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="card-stack-card card-3"&gt;
    &lt;h4&gt;Карточка 3&lt;/h4&gt;
    &lt;p&gt;Содержимое третьей карточки...&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="card-stack-card card-4"&gt;
    &lt;h4&gt;Карточка 4&lt;/h4&gt;
    &lt;p&gt;Содержимое четвертой карточки...&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>CSS Реализация</h3>
                    <p class="paragraf">Ключевые CSS свойства для этого эффекта:</p>
                    <ul class="ul">
                        <li class="li"><code>position: sticky;</code> для каждой карточки, чтобы она "залипала" при достижении определенной позиции скролла.</li>
                        <li class="li">Различные значения <code>top</code> для каждой карточки, чтобы они располагались стопкой.</li>
                        <li class="li"><code>animation-timeline: view();</code> для запуска анимации появления карточки, когда она входит в область видимости.</li>
                        <li class="li"><code>animation-range</code> для тонкой настройки момента начала и конца анимации появления.</li>
                        <li class="li"><code>transform</code> и <code>opacity</code> в кейфреймах для плавного появления и масштабирования.</li>
                    </ul>
                    <p class="paragraf">Каждая карточка имеет свою анимацию входа (<code>card-entry</code>), которая срабатывает, когда карточка появляется во вьюпорте. За счет <code>position: sticky</code> и немного отличающихся значений <code>top</code>, карточки фиксируются одна за другой, создавая эффект стопки. Контейнер <code>.card-stack-example-area</code> должен иметь достаточную высоту (например, <code>350vh</code>), чтобы обеспечить пространство для прокрутки и работы sticky-эффекта для всех карточек.</p>
                    <div class="code-block">
                        <pre><code class="language-css">.card-stack-example-area {
  height: 350vh;
  position: relative;
  padding-top: 5vh;
  margin-bottom: 10vh;
}

.card-stack-card {
  height: 70vh;
  width: 70%;
  max-width: 500px;
  margin: 0 auto 15vh auto;
  background: var(--bg-elevated, var(--bg-secondary));
  border: 1px solid var(--border-color);
  border-radius: 15px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column; 
  align-items: center;
  justify-content: center;
  text-align: center; 
  padding: 25px; 
  font-size: 1rem; 
  color: var(--text-primary);
  position: sticky;
  will-change: transform, opacity;
  opacity: 0;
  transform: scale(0.9) translateY(30px);
  animation: card-entry linear forwards;
  animation-timeline: view();
  animation-range: entry 10% entry 40%;
}

.card-stack-card:last-child {
  margin-bottom: 0;
}

.card-stack-card h4 {
  margin: 0 0 10px 0;
  font-size: 1.8em; 
  color: var(--accent-primary);
  font-weight: 600;
}
.card-stack-card p {
  font-size: 1em; 
  color: var(--text-secondary);
  margin-top: 0;
  line-height: 1.6;
}

.card-stack-card.card-1 { top: 10vh; }
.card-stack-card.card-2 { top: 13vh; }
.card-stack-card.card-3 { top: 16vh; }
.card-stack-card.card-4 { top: 19vh; }

@keyframes card-entry {
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите вниз, чтобы увидеть, как карточки последовательно появляются и "налипают" друг на друга.</p>
                    <div class="example-container"> 
                        <div class="card-stack-example-area">
                            <div class="card-stack-card card-1">
                                <h4>Карточка 1</h4>
                                <p>Это первая карточка в нашей стопке. Она появляется плавно при скролле.</p>
                            </div>
                            <div class="card-stack-card card-2">
                                <h4>Карточка 2</h4>
                                <p>Вторая карточка наезжает и фиксируется чуть ниже первой, создавая эффект стека.</p>
                            </div>
                            <div class="card-stack-card card-3">
                                <h4>Карточка 3</h4>
                                <p>Третья карточка продолжает формирование стопки, прилипая к предыдущим.</p>
                            </div>
                            <div class="card-stack-card card-4">
                                <h4>Карточка 4</h4>
                                <p>Последняя карточка завершает эффект. Прокрутите дальше, чтобы увидеть, как они остаются "налипшими".</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="cascading-text" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Каскадное появление строк текста</h2>
                <p>Эффект, где строки текста последовательно появляются с анимацией при прокрутке.</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>Описание эффекта</h3>
                    <p class="paragraf">Этот эффект создает ощущение каскадного появления строк текста: каждая строка плавно анимируется при попадании в область видимости во время прокрутки. Традиционно для такой динамической анимации текста часто прибегают к JavaScript-библиотекам, но современные CSS Scroll-Driven Animations позволяют реализовать это элегантно и производительно без дополнительного скриптинга.</p>
                    <p class="paragraf">Каждая строка текста получает собственную временную шкалу просмотра (<code>animation-timeline: view()</code>) и анимируется в определенном диапазоне видимости (<code>animation-range</code>). Это позволяет тексту "оживать" по мере его появления на экране.</p>
                </div>

                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Структура HTML довольно проста: нужен общий контейнер для области демонстрации (<code>.cascading-text-area</code>), внутри него — контейнер для самих строк текста (<code>.cascading-text-container</code>), и затем каждая строка текста оборачивается в свой элемент (например, <code>&lt;p class="cascading-text-line"&gt;</code>).</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;div class="cascading-text-area"&gt;
  &lt;div class="cascading-text-container"&gt;
    &lt;p class="cascading-text-line"&gt;Прокрутка вниз оживляет строки,&lt;/p&gt;
    &lt;p class="cascading-text-line"&gt;Словно каскад, они всплывают,&lt;/p&gt;
    &lt;p class="cascading-text-line"&gt;CSS магией своей играют,&lt;/p&gt;
    &lt;p class="cascading-text-line"&gt;Без JavaScript мир открывают.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>CSS Реализация</h3>
                    <p class="paragraf">Ключевые моменты CSS-реализации:</p>
                    <ul class="ul">
                        <li class="li"><code>.cascading-text-line</code>: К этому классу применяется основная анимация. Изначально строки смещены за пределы экрана (<code>transform: translateX(-100px)</code>) и полностью прозрачны (<code>opacity: 0</code>).</li>
                        <li class="li"><code>animation: cascade-in linear forwards;</code>: Применяет анимацию <code>cascade-in</code>.</li>
                        <li class="li"><code>animation-timeline: view();</code>: Самое важное — каждая строка получает свою независимую временную шкалу, привязанную к её появлению во вьюпорте.</li>
                        <li class="li"><code>animation-range: entry 0% contain 50%;</code>: Анимация для каждой строки начинается, как только она начинает появляться в области видимости (<code>entry 0%</code>), и полностью завершается, когда 50% элемента находится в видимой зоне (<code>contain 50%</code>). Это создает эффект последовательного появления при скролле.</li>
                        <li class="li"><code>@keyframes cascade-in</code>: Определяет плавный переход от начального состояния (за экраном, повернуто) к финальному (на своем месте, без поворота и полностью видимо). Промежуточный шаг на 60% добавляет анимации немного "упругости".</li>
                    </ul>
                    <div class="code-block">
                        <pre><code class="language-css">
.cascading-text-area {
  padding: 10vh 2rem;
  background-color: var(--bg-tertiary);
  color: var(--text-primary);
  font-family: 'Georgia', serif;
}

.cascading-text-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.cascading-text-line {
  font-size: clamp(1.5rem, 4vw, 3rem);
  line-height: 1.4;
  text-align: center;
  opacity: 0;
  transform: translateX(-100px) rotate(-5deg);
  animation: cascade-in linear forwards;
  animation-timeline: view();
  animation-range: entry 0% contain 50%;
}

@keyframes cascade-in {
  0% {
    opacity: 0;
    transform: translateX(-100px) rotate(-5deg);
  }
  60% {
    opacity: 0.8;
    transform: translateX(10px) rotate(2deg);
  }
  100% {
    opacity: 1;
    transform: translateX(0) rotate(0deg);
  }
}</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите страницу вниз, чтобы увидеть, как строки текста плавно появляются одна за другой.</p>
                    <div class="example-container" style="padding:0; margin: 0; max-width: none;">
                        <div class="cascading-text-area">
                            <div class="cascading-text-container">
                                <p class="cascading-text-line">Прокрутка вниз оживляет строки,</p>
                                <p class="cascading-text-line">Словно каскад, они всплывают,</p>
                                <p class="cascading-text-line">CSS магией своей играют,</p>
                                <p class="cascading-text-line">Без JavaScript мир открывают.</p>
                                <p class="cascading-text-line" style="margin-top: 2em; font-size: clamp(1.2rem, 3vw, 2rem); opacity:0; transform: translateY(50px);">И еще немного текста для демонстрации,</p>
                                <p class="cascading-text-line" style="font-size: clamp(1.2rem, 3vw, 2rem); opacity:0; transform: translateY(50px);">Чтобы эффект был нагляднее.</p>
                                <p class="cascading-text-line" style="font-size: clamp(1.2rem, 3vw, 2rem); opacity:0; transform: translateY(50px);">Каждая строка ждет своего часа.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="scaling-images" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Масштабирование изображений при скролле</h2>
                <p>Эффект масштабирования фонового изображения элемента при его прокрутке в области видимости.</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>Описание эффекта</h3>
                    <p class="paragraf">Этот эффект демонстрирует, как можно анимировать масштабирование фонового изображения элемента (<code>.img-wrapper</code>) по мере его прохождения через область видимости. Внутренний элемент (<code>.root</code>) используется для задания пропорций.</p>
                    <p class="paragraf">Анимация <code>scale-up</code> применяется к <code>.img-wrapper</code> и привязана к его вертикальной видимости в области просмотра (<code>animation-timeline: view(block)</code>). По мере прокрутки фон изображения будет увеличиваться с <code>100%</code> до <code>120%</code>.</p>
                </div>

                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Структура состоит из внешнего контейнера <code>.img-wrapper</code>, к которому применяется анимация масштабирования фона, и внутреннего <code>.root</code> для поддержания соотношения сторон.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;!-- Элемент для демонстрации эффекта --&gt;
&lt;div class="img-wrapper" style="background-image: url('./src/img/reveal/1.jpg');"&gt;
  &lt;div class="root"&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!-- Еще один элемент --&gt;
&lt;div class="img-wrapper" style="background-image: url('./src/img/parallax/1.jpg');"&gt;
  &lt;div class="root"&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>CSS Реализация</h3>
                    <p class="paragraf">Ключевые моменты в CSS (из файла <code>src/styles/allStyle/scaling-images.css</code>):</p>
                    <ul class="ul">
                        <li class="li"><code>.img-wrapper</code>: Устанавливает начальные стили для фона и применяет анимацию <code>scale-up</code>. <code>animation-timeline: view(block)</code> привязывает анимацию к вертикальной прокрутке элемента в области видимости.</li>
                        <li class="li"><code>.root</code>: Задает <code>aspect-ratio: 2/1</code> для определения пропорций контейнера.</li>
                        <li class="li"><code>@keyframes scale-up</code>: Анимирует <code>background-size</code> от <code>100%</code> до <code>120%</code>.</li>
                    </ul>
                    <div class="code-block">
                        <pre><code class="language-css">/* Код из src/styles/allStyle/scaling-images.css */
.img-wrapper {
    width: 46vw;
    display: flex;
    flex-direction: column;
    background-position: center;
    background-repeat: no-repeat;
    animation: scale-up linear both;
    animation-timeline: view(block);
    animation-range: cover 0% cover 100%;
}

.root {
    position: relative;
    aspect-ratio: 2/1;
}
  
@keyframes scale-up {
    from {
      background-size: 100%;
    }
    to {
      background-size: 120%;
    }
}
</code></pre>
                    </div>
                     <p class="paragraf">Ранее используемый класс <code>.wrapper</code> был переименован в <code>.img-wrapper</code>. Анимация <code>reveal</code> для элемента <code>.root</code> была удалена в текущей версии.</p>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите вниз, чтобы увидеть, как фон изображений масштабируется.</p>
                    <div class="example-container" style="display: flex; flex-direction: column; align-items: center; gap: 2rem;">
                        <div class="img-wrapper" style="background-image: url('./src/img/reveal/1.jpg');">
                            <div class="root">
                            </div>
                        </div>
                        <div class="img-wrapper" style="background-image: url('./src/img/parallax/1.jpg');">
                            <div class="root">
                            </div>
                        </div>
                        <div class="img-wrapper" style="background-image: url('./src/img/reveal/2.jpg');">
                            <div class="root">
                            </div>
                        </div>
                         <div class="img-wrapper" style="background-image: url('./src/img/parallax/2.jpg');">
                            <div class="root">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="cube-3d" class="content-section recipe-example-section tab-pane">
            <div class="section-header">
                <h2>Вращение 3D куба при скролле</h2>
                <p>Вращение 3D-куба вокруг осей X и Y с помощью независимых областей прокрутки.</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                <h3>Общее описание и ключевые CSS-свойства</h3>
                <p>
                    Этот пример демонстрирует, как можно вращать 3D-объект (в данном случае, простой куб) вокруг осей X и Y с помощью прокрутки двух независимых областей.
                    Одна область контролирует вращение по горизонтали (ось Y куба), а другая – по вертикали (ось X куба).
                </p>
                <p>
                        Ключевые CSS-свойства, используемые для этого эффекта:
                    <ul style="margin-left: 1rem;">
                        <li><code>timeline-scope: --cubeScrollerX, --cubeScrollerY;</code> на общем контейнере для объявления именованных временных шкал.</li>
                        <li><code>scroll-timeline-name: --cubeScrollerX;</code> и <code>scroll-timeline-axis: x;</code> (аналогично для Y) на элементах-скрабберах.</li>
                        <li><code>animation-timeline: --cubeScrollerX, --cubeScrollerY;</code> на элементе сцены с кубом, чтобы связать анимации с соответствующими временными шкалами.</li>
                        <li><code>@property --cube-x-angle { syntax: "<angle>"; inherits: false; initial-value: -25deg; }</code> (и <code>--cube-y-angle</code>) для регистрации кастомных CSS-свойств, которые будут анимироваться.</li>
                        <li><code>perspective</code> на родительском контейнере (<code>#tridiv</code>) для создания 3D-контекста.</li>
                        <li><code>transform-style: preserve-3d;</code> на сцене и на самом кубе, чтобы дочерние элементы корректно отображались в 3D-пространстве.</li>
                        <li>Базовый <code>font-size</code> (например, <code>10px</code>) на контейнере <code>#tridiv</code> важен, так как размеры куба и его граней заданы в <code>em</code>, что делает их относительными к этому значению.</li>
                    </ul>
                    Куб состоит из шести граней (<code>&lt;div class="face"&gt;</code>), каждая из которых позиционируется с помощью CSS 3D-трансформаций.
                </p>
            </div>

            <div class="code-block">
                <p>Пример HTML разметки:</p>
                <pre><code class="language-html">
&lt;!-- Обертка для задания timeline-scope --&gt;
&lt;div class="cube-3d-body-wrapper"&gt;
  &lt;!-- Контейнер для скроллеров и области просмотра куба --&gt;
  &lt;div class="cube-controls-container"&gt;
    &lt;!-- Горизонтальный скроллер --&gt;
    &lt;div class="cube-scroller-card scroll-x-container"&gt;
      &lt;div class="scroll-content"&gt;
        &lt;div class="scroll-content-item"&gt;Скролл X: Старт&lt;/div&gt;
        &lt;div class="scroll-content-item"&gt;Скролл X: Середина&lt;/div&gt;
        &lt;div class="scroll-content-item"&gt;Скролл X: Почти конец&lt;/div&gt;
        &lt;div class="scroll-content-item"&gt;Скролл X: Конец&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Вертикальный скроллер --&gt;
    &lt;div class="cube-scroller-card scroll-y-container"&gt;
      &lt;div class="scroll-content"&gt;
        &lt;div class="scroll-content-item"&gt;Скролл Y: Старт&lt;/div&gt;
        &lt;div class="scroll-content-item"&gt;Скролл Y: Середина&lt;/div&gt;
        &lt;div class="scroll-content-item"&gt;Скролл Y: Почти конец&lt;/div&gt;
        &lt;div class="scroll-content-item"&gt;Скролл Y: Конец&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Область просмотра куба --&gt;
    &lt;div class="cube-viewer"&gt;
      &lt;div id="tridiv"&gt;
        &lt;div class="scene"&gt;
          &lt;div class="shape cuboid demo-cube"&gt;
            &lt;div class="face ft"&gt;Передняя&lt;/div&gt;
            &lt;div class="face bk"&gt;Задняя&lt;/div&gt;
            &lt;div class="face rt"&gt;Правая&lt;/div&gt;
            &lt;div class="face lt"&gt;Левая&lt;/div&gt;
            &lt;div class="face tp"&gt;Верхняя&lt;/div&gt;
            &lt;div class="face bm"&gt;Нижняя&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
                </code></pre>
            </div>

            <div class="code-block">
                <p>Ключевые моменты CSS (из <code>cube-3d.css</code>):</p>
                <pre><code class="language-css">
.cube-3d-body-wrapper {
  timeline-scope: --cubeScrollerX, --cubeScrollerY;
  overflow: visible; /* Важно, чтобы perspective для #tridiv не обрезался */
  padding: 1rem;
}

.cube-scroller-card {
  background-color: var(--bg-tertiary, #2a2a2a);
  padding: 1rem;
  min-height: 7rem;
  border: 1px solid var(--border-color, #444);
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  scroll-snap-type: both mandatory; /* Для прилипания при скролле */
}

.scroll-x-container {
  scroll-timeline-name: --cubeScrollerX;
  scroll-timeline-axis: x;
  overflow-x: scroll;
  overflow-y: hidden;
}

.scroll-y-container {
  scroll-timeline-name: --cubeScrollerY;
  scroll-timeline-axis: y;
  overflow-y: scroll;
  overflow-x: hidden;
  height: 7rem;
}

.scroll-content {
  display: flex;
  flex-wrap: nowrap;
  height: 100%; 
  width: 100%;
}
.scroll-x-container .scroll-content { flex-direction: row; width: 400%; }
.scroll-y-container .scroll-content { flex-direction: column; height: 400%; }

.scroll-content-item {
   flex-shrink: 0;
   width: 100%;
   height: 100%;
   scroll-snap-align: start;
   padding: 10px 15px;
   display: flex;
   align-items: center;
   justify-content: center;
   text-align: center;
   box-sizing: border-box;
}

.cube-viewer {
  background-color: var(--bg-secondary, #1e1e1e);
  border: 1px solid var(--border-color, #444);
  border-radius: 12px;
  padding: 1rem;
  min-height: 400px;
  position: relative;
  overflow: hidden;
}

#tridiv {
  perspective: 800px;
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  font-size: 10px;
  overflow: visible;
}

.scene {
  position: absolute;
  width: 100%; height: 100%;
  top: 50%; left: 50%;
  transform-style: preserve-3d;
  transform: translate(-50%, -50%) 
             rotateX(var(--cube-x-angle, -25deg))
             rotateY(var(--cube-y-angle, -25deg))
             scale(var(--cube-scale, 0.8));
  animation: rotateHorizontalCube linear, rotateVerticalCube linear;
  animation-timeline: --cubeScrollerX, --cubeScrollerY;
}

.shape.demo-cube {
  position: absolute;
  width: 15em; height: 15em;
  top: 50%; left: 50%;
  margin-left: -7.5em;
  margin-top: -7.5em; 
  transform-style: preserve-3d;
}

.demo-cube .face {
  position: absolute;
  width: 15em; height: 15em;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.6em;
  font-weight: bold;
  color: var(--text-on-accent-strong, #FFFFFF);
  border: 1px solid rgba(255, 255, 255, 0.35); /* Исправлено */
  backface-visibility: hidden;
  box-sizing: border-box;
  padding: 0.5em;
  text-align: center;
}

.demo-cube .ft { transform: translateZ(7.5em); background-color: var(--color-red-700-alpha-85, rgba(229, 57, 53, 0.85)); }
.demo-cube .bk { transform: rotateY(180deg) translateZ(7.5em); background-color: var(--color-green-700-alpha-85, rgba(67, 160, 71, 0.85)); }
.demo-cube .rt { transform: rotateY(90deg) translateZ(7.5em); background-color: var(--color-blue-700-alpha-85, rgba(25, 118, 210, 0.85)); }
.demo-cube .lt { transform: rotateY(-90deg) translateZ(7.5em); background-color: var(--color-yellow-600-alpha-85, rgba(253, 216, 53, 0.85)); }
.demo-cube .tp { transform: rotateX(90deg) translateZ(7.5em); background-color: var(--color-purple-700-alpha-85, rgba(123, 31, 162, 0.85)); }
.demo-cube .bm { transform: rotateX(-90deg) translateZ(7.5em); background-color: var(--color-orange-500-alpha-85, rgba(255, 138, 101, 0.85)); }

@property --cube-x-angle { syntax: "<angle>"; inherits: false; initial-value: -25deg; }
@property --cube-y-angle { syntax: "<angle>"; inherits: false; initial-value: -25deg; }
@property --cube-scale { syntax: "<number>"; inherits: false; initial-value: 0.8; } /* Добавлено */

@keyframes rotateHorizontalCube {
  from { --cube-y-angle: -25deg; }
  to   { --cube-y-angle: calc(-25deg + 360deg); }
}

@keyframes rotateVerticalCube {
  from { --cube-x-angle: -25deg; }
  to   { --cube-x-angle: calc(-25deg + 360deg); }
}
                </code></pre>
            </div>

            <div class="demo-block">
                <h3>Интерактивное демо:</h3>
                <div class="cube-3d-body-wrapper">
                    <div class="cube-controls-container">
                        <div class="cube-scroller-card scroll-x-container">
                            <div class="scroll-content">
                                <div class="scroll-content-item">Горизонтальный скролл (Y-ось куба): Старт</div>
                                <div class="scroll-content-item">Середина</div>
                                <div class="scroll-content-item">Почти конец</div>
                                <div class="scroll-content-item">Конец</div>
                            </div>
                        </div>
                    
                        <div class="cube-scroller-card scroll-y-container">
                            <div class="scroll-content">
                                <div class="scroll-content-item">Вертикальный скролл (X-ось куба): Старт</div>
                                <div class="scroll-content-item">Середина</div>
                                <div class="scroll-content-item">Почти конец</div>
                                <div class="scroll-content-item">Конец</div>
                            </div>
                        </div>
                    
                        <div class="cube-viewer">
                            <div id="tridiv">
                                <div class="scene">
                                    <div class="shape cuboid demo-cube">
                                        <div class="face ft">Передняя</div>
                                        <div class="face bk">Задняя</div>
                                        <div class="face rt">Правая</div>
                                        <div class="face lt">Левая</div>
                                        <div class="face tp">Верхняя</div>
                                        <div class="face bm">Нижняя</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </section>

    </main>

    <script src="./src/js/tabs.js" type="module"></script>
    <script src="https://flackr.github.io/scroll-timeline/dist/scroll-timeline.js"></script>
</body>
</html>
