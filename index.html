<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scroll-Animations Lab</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.png" />
    <link rel="stylesheet" href="/src/styles/allStyle/fonts.css">
    <link rel="stylesheet" href="/src/styles/dark-theme.css">
    <link rel="stylesheet" href="/src/styles/allStyle/oneSection-style.css">
    <link rel="stylesheet" href="/src/styles/allStyle/twoSection-style.css">
    <link rel="stylesheet" href="/src/styles/allStyle/test.style.css">
    <link rel="stylesheet" href="/src/styles/allStyle/carousel-style.css">
    <link rel="stylesheet" href="/src/styles/allStyle/image-reveal.css">
    <link rel="stylesheet" href="/src/styles/allStyle/parallax.css">
    <link rel="stylesheet" href="/src/styles/allStyle/super-scroll.css">
    <link rel="stylesheet" href="/src/styles/allStyle/progress-bar.css">
    <link rel="stylesheet" href="/src/styles/allStyle/card-stack.css">
    <link rel="stylesheet" href="/src/styles/allStyle/cascading-text-reveal.css">
    <link rel="stylesheet" href="/src/styles/allStyle/scaling-images.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="page-progress-bar"></div>
    <button class="mobile-menu-toggle">
        <i class="fas fa-bars"></i>
    </button>

    <aside class="sidebar">
        <div class="sidebar-header">
            <h1>Scroll Animations</h1>
            <p>Interactive demos and code examples</p>
        </div>
        <nav>
            <ul class="nav-links">
                <li class="nav-item">
                    <a href="#general-info" class="nav-link" data-title="Обзор технологии Scroll-Driven Animations">
                        <i class="icon fas fa-book-open"></i>
                        Обзор технологии
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#recipes-container" class="nav-link" data-title="Рецепты Scroll-Driven Animations">
                        <i class="icon fas fa-flask"></i>
                        Рецепты
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#polyfill" class="nav-link" data-title="Polyfill, ограничения и общая информация">
                        <i class="icon fas fa-info-circle"></i>
                        Polyfill, ограничения и общая информация
                    </a>
                </li>
            </ul>
        </nav>
    </aside>

    <header class="header">
        <h1>Scroll Animations</h1>
    </header>

    <!-- Main Content Area -->
    <main class="content-wrapper">
        <!-- NEW CONTENT SECTION: General Information -->
        <section id="general-info" class="content-section">
            <div class="section-header">
                <h2>Обзор технологии Scroll-Driven Animations</h2>
                <p>Подробное описание, ключевые концепции, области применения, плюсы и минусы.</p>
            </div>
            <div class="section-body">
                <!-- User's Point 2: Описание технологии -->
                <div class="docs-block">
                    <h3>Описание технологии</h3>
                    <p class="paragraf">Для управления анимацией связанной со скроллом добавлены две концепции это Scroll Timelines and View Timelines или Временная шкала (<a href="https://drafts.csswg.org/scroll-animations-1/" target="_blank" rel="noopener noreferrer">спецификация W3C</a>) прогресса прокрутки и временная шкала просмотра.</p>
                    <p class="paragraf">По умолчанию у нас есть только одна временная шкала и это временная шкала документа, но с этой спецификацией появляется еще две временных шкалы. Временная шкала прогресса прокрутки (Scroll Progress Timeline) и временная шкала просмотра (View Progress Timeline). Первая закрепляется и отслеживает прогресс прокрутки контейнера в процентах. А вторая отслеживает относительное положение элемента в его контейнере прокрутки.</p>
                    <p class="paragraf">Общее описание:<br />
                    <strong>Scroll Progress Timeline</strong> - Позволяет отслеживать прогресс прокрутки контейнера.<br />
                    <strong>View Progress Timeline</strong> - Позволяет отслеживать прогресс прокрутки конкретного элемента в нашем экране. Или в нашей зоне видимости.</p>
                    <p class="paragraf">Также это свойство позволяет нам гибко настраивать, в какой момент должна начинаться и заканчиваться анимация. Мы можем запускать анимацию только в момент пересечения объекта с нашей областью видимости или при выходе его из нее. Также можно заканчивать анимацию на середине экрана или начинать как только объект полностью вошел в область видимости.</p>

                    <h4>Scroll Progress Timeline</h4>
                    <p class="paragraf">Начнем с использования временной шкалы прогресса прокрутки:</p>
                    <div class="code-block"><pre><code class="language-css">animation: animate-it linear both; /* 'both' для удержания состояния */
animation-timeline: scroll(root block);
/* Время анимации не указывается (auto по умолчанию) */</code></pre></div>
                    <p class="paragraf">В комбинированном свойстве animation нам нужно указать название анимации (animatie-it) функцию анимации (linear), также для корректной работы полифила и показа анимации при загрузке страницы нужно указать fill-mode = both, что позволит анимации быть не прерываться, так как в таком случае после окончания анимации к элементу применяется стили для последнего кадра и у нас не будет прыгать наша анимация к началу, после того, как мы полностью. прокрутили контейнер. Обязательно нужно не указывать время анимации. Для корректной работы нужно оставить его в auto. Можно просто не указывать, так как по умолчанию он auto.</p>
                    <p class="paragraf">Далее мы создаем временную школу прокрутки, относительно которой и будет происходить анимация. Для этого пользуемся свойством animation-timeline и как значение указываем функцию scroll() которая принимает два значения. Первое это контейнер, который используем для отслеживания прокрутки. Тут может быть 3 значения:</p>
                    <ul class="ul">
                        <li class="li"><code>nearest</code>: использует контейнер прокрутки ближайшего предка (по умолчанию).</li>
                        <li class="li"><code>root</code>: использует область просмотра документа в качестве контейнера прокрутки.</li>
                        <li class="li"><code>self</code>: использует сам элемент в качестве контейнера прокрутки.</li>
                    </ul>
                    <p class="paragraf">И второе это ось. Тут может быть 4 значения:</p>
                    <ul class="ul">
                        <li class="li"><code>block</code>: использует меру прогресса вдоль оси блока контейнера прокрутки (по умолчанию).</li>
                        <li class="li"><code>inline</code>: использует меру прогресса вдоль встроенной оси контейнера прокрутки.</li>
                        <li class="li"><code>y</code>: использует меру прогресса по оси y контейнера прокрутки.</li>
                        <li class="li"><code>x</code>: использует меру прогресса по оси x контейнера прокрутки.</li>
                    </ul>
                    <p class="paragraf">Так в примере мы привязались к оси прокрутки нашего документа и используем его основную ось, то есть сверху вниз.</p>
                    <p class="paragraf">Также мы можем использовать именованную временную шкалу прогресса прокрутки. Что позволит нам привязать ее к любому элементу и выбрать ось. После чего указать в другом элементе для выполнения анимации.</p>
                    <div class="code-block"><pre><code class="language-css">.scroller {
  scroll-timeline-name: --my-scroller;
  scroll-timeline-axis: inline; /* или короткая запись: scroll-timeline: --my-scroller inline; */
}

.scroller .subject {
  animation: animate-it linear both;
  animation-timeline: --my-scroller;
}</code></pre></div>

                    <h4>View Progress Timeline</h4>
                    <p class="paragraf">Далее рассмотрим возможность работы с временной шкалой просмотра:</p>
                    <div class="code-block"><pre><code class="language-css">@keyframes reveal {
  from { opacity: 0; }
  to { opacity: 1; }
}

img {
  animation: reveal linear both;
  animation-timeline: view(); /* Ось по умолчанию 'block' */
}</code></pre></div>
                    <p class="paragraf">Значения для свойства animation указываются также, как и для scroll timeline. Но есть отличие в указании значений для свойства animation-timeline. Для задания временной шкалы просмотра нужно использовать функцию view() которая принимает 2 аргумента. Также как и в первом свойстве есть аргумент для задания оси прокрутки. По умолчанию это block.</p>
                    <p class="paragraf">Второй аргумент отвечает за смещение анимации. Может принимать следующие значения:</p>
                    <ul class="ul">
                        <li class="li"><code>cover</code>: представляет полный диапазон временной шкалы просмотра.</li>
                        <li class="li"><code>entry</code>: представляет диапазон, в течение которого основное поле входит в диапазон видимости прогресса просмотра.</li>
                        <li class="li"><code>exit</code>: представляет диапазон, в течение которого основной блок выходит из диапазона видимости прогресса просмотра.</li>
                        <li class="li"><code>entry-crossing</code>: представляет диапазон, в течение которого основной блок пересекает край конечной границы.</li>
                        <li class="li"><code>exit-crossing</code>: представляет диапазон, в течение которого основной блок пересекает край начальной границы.</li>
                        <li class="li"><code>contain</code>: представляет диапазон, в течение которого основной блок либо полностью содержится, либо полностью покрывает диапазон видимости прогресса просмотра в области прокрутки. Это зависит от того, выше или короче объект скроллера. (Анимация начинает проигрываться, только когда объект полностью появился в поле зрения)</li>
                    </ul>
                    <p class="paragraf">Чтобы установить правила для начала и окончания анимации нужно использовать свойство <code>animation-range</code>. Где мы можем указать любое из вышеперечисленных значений и процент, на сколько оно выполняется. Так для начала анимации при входе в область видимости и окончании, когда объект полностью в нее войдет нужно использовать такие значения:</p>
                    <div class="code-block"><pre><code class="language-css">animation-range: entry 0% entry 100%;</code></pre></div>
                    <p class="paragraf">Чтобы лучше разобраться в этих свойствах есть инструмент конструктор, в котором вы можете попробовать их все: <a href="https://scroll-driven-animations.style/tools/view-timeline/ranges" target="_blank" rel="noopener noreferrer">View Timeline Ranges Visualizer</a>.</p>
                    <p class="paragraf">Нужно обратить внимание, что эти диапазоны получены из не преобразованного основного блока субъекта. Это означает, что такие преобразования, как scale и translate, не учитываются при определении диапазонов. Что позволяет нам использовать смещение и увеличения для создания анимации.</p>
                    <p class="paragraf">Аналогично scroll timeline мы также можем создавать именованные временные шкалы просмотра, то есть view-timeline. И применять к ним те же значения, а после передавать в свойство animation-timeline.</p>
                    <p class="paragraf">Например, вот так:</p>
                    <div class="code-block"><pre><code class="language-css">.revealing-image {
  view-timeline-name: --revealing-image;
  view-timeline-axis: block;

  animation: reveal linear both;
  animation-timeline: --revealing-image;
  animation-range: entry 25% cover 50%;
}</code></pre></div>
                </div>

                <div class="docs-block">
                    <h3>Плюсы и минусы технологии</h3>
                    <h4>Плюсы:</h4>
                    <ul class="ul">
                        <li class="li"><strong>Производительность:</strong> Технология не использует основной поток выполнения javascript, что позволяет работать плавно и не мешать вычислениям в основном потоке.</li>
                        <li class="li"><strong>Лаконичность:</strong> Многие популярные анимации можно сделать в несколько строк кода и не нужно ничего придумывать.</li>
                        <li class="li"><strong>Гибкость:</strong> Можно очень гибко настроить позицию для начала выполнения и окончания анимации.</li>
                        <li class="li"><strong>Простота в использовании:</strong> Здесь все работает как обычные css анимации, поэтому ничего не нужно изучать дополнительно.</li>
                    </ul>
                    <h4>Минусы:</h4>
                    <ul class="ul">
                        <li class="li"><strong>Не работает нативно в safari:</strong> Сейчас нет поддержки safari, но есть polyfill, который должен решать эту проблему, но с его использованием тоже есть особенности, о которых поговорим далее.</li>
                        <li class="li"><strong>Мало примеров, документации и решения разных проблем:</strong> Есть документация в chrome и еще вот этот сайт <a href="https://scroll-driven-animations.style/" target="_blank" rel="noopener noreferrer">https://scroll-driven-animations.style/</a>. Кроме этого никакой информации связанной с технологией нет. И решать разные проблемы связанные с разработкой на этой технологии придется вам самим.</li>
                    </ul>
                </div>

                <div class="docs-block">
                    <h3>Ссылки на источники</h3>
                    <ul class="ul">
                        <li class="li"><a href="https://scroll-driven-animations.style/" target="_blank" rel="noopener noreferrer">scroll-driven-animations.style</a> - Сайт с примерами, ссылками на другие ресурсы и конструктором для тестирования анимаций. Вся информация на английском. Нет подробного описания технологии. А также моментов работы с NextJS и polyfill.</li>
                        <li class="li"><a href="https://habr.com/ru/companies/skillfactory/articles/587792/" target="_blank" rel="noopener noreferrer">Habr: Skillfactory</a> - Перевод части документации. Рассматривают использование анимации при помощи JS, а у нас идет повествовании о css.</li>
                        <li class="li"><a href="https://habr.com/ru/articles/749794/" target="_blank" rel="noopener noreferrer">Habr: Сравнение производительности</a> - Перевод статьи, где происходит сравнение производительности с новым API на CSS и JS против старых анимаций на JS. Нет подробного описания работы с технологиями и особенности работы с nextJS. Также в сравнении производительности используют только один эффект.</li>
                        <li class="li"><a href="https://developer.chrome.com/docs/css-ui/scroll-driven-animations" target="_blank" rel="noopener noreferrer">Chrome Developers</a> - Основная документация с теорией того, как все работает и примерами. Эта документация на английском.Нет особенностей работы с polyfill и NextJS.</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- NEW CONTENT SECTION: Recipes Container -->
        <section id="recipes-container" class="content-section">
            <div class="section-header">
                <h2>Рецепты Scroll-Driven Animations</h2>
                <p>Коллекция готовых примеров и техник.</p>
            </div>
            <div class="section-body">
                <!-- Second-level tab navigation will go here -->
                <nav class="recipes-nav">
                    <ul class="recipes-nav-links">
                        <li><a href="#horizontal-scroll" class="recipe-nav-link" data-title="Горизонтальный скролл">Горизонтальный скролл</a></li>
                        <li><a href="#carousel" class="recipe-nav-link" data-title="Карусель с маркерами">Карусель</a></li>
                        <li><a href="#reveal" class="recipe-nav-link" data-title="Появление изображения">Появление изображения</a></li>
                        <li><a href="#parallax" class="recipe-nav-link" data-title="Параллакс эффект">Параллакс</a></li>
                        <li><a href="#svg-animation" class="recipe-nav-link" data-title="SVG Анимация">SVG Анимация</a></li>
                        <li><a href="#progress-bar" class="recipe-nav-link" data-title="Индикатор прогресса">Индикатор прогресса</a></li>
                        <li><a href="#card-stack" class="recipe-nav-link" data-title="Карточки (Card Stack)">Стопка Карточек</a></li>
                        <li><a href="#cascading-text" class="recipe-nav-link" data-title="Каскадное появление текста">Каскадное появление текста</a></li>
                        <li><a href="#scaling-images" class="recipe-nav-link" data-title="Масштабирование изображений">Масштабирование изображений</a></li>
                    </ul>
                </nav>
            </div>
        </section>
        <section id="horizontal-scroll" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Горизонтальный скролл при вертикальной прокрутке</h2>
                <p>Создание горизонтальной анимации, управляемой вертикальным скроллом страницы</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Для создания эффекта горизонтального скролла при вертикальной прокрутке, мы используем элемент, который "прилипает" к верхней части экрана, в то время как его содержимое двигается горизонтально.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;section class="sectionPin"&gt;
  &lt;div class="pin-wrap-sticky"&gt;
    &lt;div class="pin-wrap"&gt;
      &lt;div class="q"&gt;&lt;/div&gt;
      &lt;div class="content"&gt;
        &lt;h1 class="text"&gt;Scroll-driven Animations&lt;/h1&gt;
        &lt;p class="text-i"&gt;created by &lt;br/&gt; Author Name&lt;/p&gt;
      &lt;/div&gt;       
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/section&gt;</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>CSS Анимация</h3>
                    <p class="paragraf">Ключевые моменты в CSS: создание timeline-view, sticky-позиционирование и анимация transform с опорой на скролл.</p>
                    <div class="code-block">
                        <pre><code class="language-css">@keyframes move {
  to {
    transform: translateX(calc(-100% + 100vw));
  }
}

.sectionPin {
  height: 300vh; /* Пространство для скролла */
  overflow: visible;
  view-timeline-name: --section-pin-tl; /* Используется для привязки анимации */
  view-timeline-axis: block; /* Отслеживание по вертикальной оси */
}

.pin-wrap-sticky {
  height: 100vh;
  width: 100vw;
  position: sticky; /* Элемент "прилипает" */
  top: 0;
  overflow-x: hidden; /* Скрываем горизонтальный скроллбар */
}

.pin-wrap {
  height: 100vh;
  width: 179vmax; /* Широкий контейнер для горизонтального контента */
  will-change: transform; /* Оптимизация производительности */
  animation: linear move forwards; /* Применяем анимацию 'move' */
  animation-timeline: --section-pin-tl; /* Привязка к таймлайну */
  animation-range: contain 0% contain 100%; /* Анимация активна, пока контейнер в зоне видимости */
}</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Вариант с изображениями</h3>
                    <p class="paragraf">Подобный эффект можно применить и к галерее изображений.</p>
                    <div class="example-container tall-example">
                        <section class="test">
                            <div class="sticky-pin">
                                <div class="wrap-pin">
                                    <div class="q"></div>
                                    <div class="container">
                                        <img class="pin" src="https://img.freepik.com/free-photo/beautiful-mountain-forest-landscape_23-2149063036.jpg?size=626&ext=jpg" alt="Mountain Forest">
                                        <img class="pin" src="https://img.freepik.com/free-photo/mountainous-nature-landscape-with-river_23-2150705792.jpg?size=626&ext=jpg" alt="Mountain River">
                                        <img class="pin" src="https://img.freepik.com/free-photo/assortment-of-colored-plant-leaves_23-2149337900.jpg?size=626&ext=jpg" alt="Colored Leaves">
                                        <img class="pin" src="https://img.freepik.com/free-photo/beautiful-palm-tree-in-vivid-colors_23-2151591807.jpg?size=626&ext=jpg" alt="Palm Tree">
                                        <img class="pin" src="https://img.freepik.com/premium-photo/guy-on-the-edge-of-the-prelude-to-preikestolen-norway_7509-960.jpg?size=626&ext=jpg&ga=GA1.1.1818441046.1720137018&semt=ais_user" alt="Preikestolen">
                                    </div>
                                </div>
                            </div>
                        </section>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 2: Carousel with Markers -->
        <section id="carousel" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Карусель с маркерами</h2>
                <p>Горизонтальная карусель изображений с синхронизированными маркерами</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Карусель состоит из двух основных компонентов: контейнера с изображениями и маркеров, которые указывают текущее положение.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;div data-component="carousel"&gt;
  &lt;ul class="entries" tabindex="0"&gt;
    &lt;li class="l"&gt;&lt;a name="carousel_01"&gt;&lt;img class="slide" src="..." alt=""&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;!-- Другие слайды --&gt;
  &lt;/ul&gt;
  &lt;ul class="markers"&gt;
    &lt;li class="Li"&gt;&lt;a href="#carousel_01"&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;!-- Другие маркеры --&gt;
  &lt;/ul&gt;
&lt;/div&gt;</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>CSS Реализация</h3>
                    <p class="paragraf">Ключевой момент - использование scroll-timeline для синхронизации маркеров с прокруткой контента.</p>
                    <div class="code-block">
                        <pre><code class="language-css">/* Определяем ключ-кадры для активного состояния маркера */
@keyframes activate-marker { 
  to { 
    background-color: var(--accent-primary); 
    transform: scale(1.2); 
    opacity: 1;
  }
}

[data-component="carousel"] {
  /* Создаем именованную область видимости для таймлайна */
  timeline-scope: --carousel;
}

.entries {
  /* Привязываем таймлайн к горизонтальной прокрутке списка .entries */
  scroll-timeline: --carousel x; 
}

.markers a {
  /* Анимация для маркеров, привязанная к таймлайну --carousel */
  animation: activate-marker linear forwards;
  animation-timeline: --carousel;
  animation-fill-mode: both; /* 'both' не требуется с forwards, но оставлено для ясности */
  
  /* Динамический расчет диапазона анимации для каждого маркера */
  /* Анимация активна, когда соответствующий слайд находится в видимой части */
  animation-range-start: calc((var(--i) - 1) * 25%);
  animation-range-end: calc(var(--i) * 25%);
}

/* Пример задания переменной --i для каждого маркера (обычно делается в HTML или CSS) */
/* .markers li:nth-child(1) a { --i: 1; } */
/* .markers li:nth-child(2) a { --i: 2; } */
/* ... и так далее для всех маркеров */
</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите карусель и наблюдайте, как маркеры активируются в соответствии с положением контента.</p>
                    <div class="example-container">
                        <section class="cont">
                            <div data-component="carousel">
                                <ul class="entries" tabindex="0">
                                    <li class="l"><a name="carousel_01"><img class="slide" src="https://img.freepik.com/premium-photo/scenic-view-of-rocks-in-sea-against-clear-sky_1048944-19066138.jpg?size=626&ext=jpg&ga=GA1.1.1143220769.1720183557&semt=ais_user" alt="Rocks in sea" draggable="false"></a></li>
                                    <li class="l"><a name="carousel_02"><img class="slide" src="https://img.freepik.com/premium-photo/cluster-of-purple-and-blue-leaves_118124-302144.jpg?size=626&ext=jpg&ga=GA1.1.1143220769.1720183557&semt=ais_user" alt="Purple leaves" draggable="false"></a></li>
                                    <li class="l"><a name="carousel_03"><img class="slide" src="https://img.freepik.com/free-photo/beautiful-scenery-of-green-trees-near-the-body-of-water-over-high-mountains_181624-18193.jpg?size=626&ext=jpg&ga=GA1.1.1143220769.1720183557&semt=ais_user" alt="Green trees" draggable="false"></a></li>
                                    <li class="l"><a name="carousel_04"><img class="slide" src="https://img.freepik.com/free-photo/mountainous-nature-landscape-with-river_23-2150705796.jpg?size=626&ext=jpg&ga=GA1.1.1143220769.1720183557&semt=ais_user" alt="Mountain river" draggable="false"></a></li>
                                </ul>
                                <ul class="markers">
                                    <li class="Li"><a href="#carousel_01"></a></li>
                                    <li class="Li"><a href="#carousel_02"></a></li>
                                    <li class="Li"><a href="#carousel_03"></a></li>
                                    <li class="Li"><a href="#carousel_04"></a></li>
                                </ul>
                            </div>
                        </section>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: Reveal Image -->
        <section id="reveal" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Появление изображения</h2>
                <p>Эффект появления изображений при скролле страницы</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>Принцип работы</h3>
                    <p class="paragraf">Эта техника использует view timeline для анимации появления изображения при его попадании в область видимости.</p>
                    <div class="code-block">
                        <pre><code class="language-css">@keyframes reveal {
  from {
    opacity: 0;
    transform: translateY(100px); /* Обновлено: было 20px, убран clip-path */
  }
  to {
    opacity: 1;
    transform: translateY(0px); /* Обновлено: было translateY(0), убран clip-path */
  }
}

.revealing-image {
  /* Задаем имя для view-timeline и ось отслеживания */
  view-timeline-name: --revealing-image;
  view-timeline-axis: block;

  /* Применяем анимацию */
  animation: linear reveal both;
  /* Привязываем анимацию к созданному view-timeline */
  animation-timeline: --revealing-image;
  /* Диапазон анимации: начинается, когда элемент входит на 0% в зону видимости,
     и полностью виден (cover) на 50% этой зоны */
  animation-range: entry 0% cover 50%;
}</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите вниз, чтобы увидеть, как изображения появляются, когда входят в область видимости.</p>
                    <div class="example-container">
                        <section class="reveal">
                            <div class="title center" style="text-align:center; margin-bottom:1em;">
                                <h3 class="text-two" style="margin-bottom:0.5em;">Изображения с эффектом появления</h3>
                            </div>
                            <img class="image revealing-image" src="./src/img/reveal/1.jpg" alt="Anime girl 1">
                            <img class="image revealing-image" src="./src/img/reveal/2.jpg" alt="Anime girl 2">
                        </section>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 4: Parallax -->
        <section id="parallax" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Параллакс эффект</h2>
                <p>Создание эффекта параллакса при прокрутке изображений</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>HTML и CSS реализация</h3>
                    <p class="paragraf">При горизонтальной прокрутке слайдов, изображения внутри них двигаются с разной скоростью, создавая эффект глубины.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;ul class="slides"&gt;
  &lt;li class="slide"&gt;&lt;img src="..." alt=""&gt;&lt;/li&gt;
  &lt;!-- Другие слайды --&gt;
&lt;/ul&gt;</code></pre>
                    </div>
                    <div class="code-block">
                        <pre><code class="language-css">/* Базовые стили для изображения внутри слайда */
.slide &gt; img {
  object-fit: cover; /* Масштабирует изображение с сохранением пропорций, обрезая лишнее */
  object-position: 100% 0; /* Начальная позиция изображения (справа по горизонтали, сверху по вертикали) */
  display: block; /* Убирает лишние отступы */
  width: 100%;
  height: 100%;
  position: absolute; /* Для точного позиционирования object-position */
  right: 0; /* Выравнивание по правому краю слайда */
}

/* Ключевые кадры для анимации параллакса */
@keyframes adjust-image { /* Имя изменено с parallax-scroll */
  0% { /* Начальное состояние (соответствует object-position в .slide > img) */
    object-position: 100% 0; /* Изображение смещено вправо */
  }
  100% { /* Конечное состояние */
    object-position: 0 0;   /* Изображение смещено влево */
  }
}

/* Применение анимации к изображениям в слайдах */
.slide &gt; img {
  animation: adjust-image linear both; /* 'both' удерживает состояние анимации */
  animation-timeline: view(x); /* Анимация привязана к горизонтальной прокрутке родительского .slide */
}</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите галерею горизонтально и наблюдайте за эффектом параллакса на изображениях.</p>
                    <div class="example-container">
                        <ul class="slides">
                            <li class="slide"><img src="./src/img/parallax/1.jpg" alt="Parallax 1"></li>
                            <li class="slide"><img src="./src/img/parallax/2.jpg" alt="Parallax 2"></li>
                            <li class="slide"><img src="./src/img/parallax/3.jpg" alt="Parallax 3"></li>
                            <li class="slide"><img src="./src/img/parallax/4.jpg" alt="Parallax 4"></li>
                            <li class="slide"><img src="./src/img/parallax/5.jpg" alt="Parallax 5"></li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 5: SVG Animation -->
        <section id="svg-animation" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>SVG Анимация</h2>
                <p>Анимация SVG элементов при прокрутке страницы</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>SVG и CSS</h3>
                    <p class="paragraf">SVG элементы могут быть анимированы с помощью CSS и привязаны к прокрутке страницы.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;section class="super-scroll"&gt;
  &lt;div class="super-svg"&gt;
    &lt;svg viewBox="0 0 100 100" class="super-svg-1"&gt;
      &lt;circle cx="50" cy="50" r="40" /&gt;
    &lt;/svg&gt;
    &lt;svg viewBox="0 0 800 120" class="super-svg-text"&gt;
      &lt;text x="50%" y="50%" ...&gt;Scroll-Driven Animation&lt;/text&gt;
    &lt;/svg&gt;
    &lt;svg viewBox="0 0 100 100" class="super-svg-2"&gt;
      &lt;rect x="10" y="10" width="80" height="80" rx="10"/&gt;
    &lt;/svg&gt;
  &lt;/div&gt;
&lt;/section&gt;</code></pre>
                    </div>
                    <div class="code-block">
                        <pre><code class="language-css">.super-scroll {
  height: 200vh; /* Пространство для скролла */
  position: relative;
  view-timeline-name: --super-scroll-tl; /* Имя таймлайна изменено (было --svg-scroll-tl) */
  view-timeline-axis: block;
  overflow: visible;
  padding-inline: 2vw;
}

/* Анимация для первого SVG элемента (круга) */
.super-svg-1 { /* Селектор изменен, анимация применяется к SVG контейнеру */
  stroke-dasharray: 251; /* Для эффекта "рисования" */
  stroke-dashoffset: 251;
  animation: circle-rotate linear forwards; /* Имя keyframes изменено */
  animation-timeline: --super-scroll-tl; /* Привязка к таймлайну */
  animation-range: contain 0% contain 100%; /* Диапазон изменен */
}

@keyframes circle-rotate {
  0% {
    stroke-dashoffset: 251;
    transform: rotate(0deg);
  }
  100% {
    stroke-dashoffset: 0;
    transform: rotate(360deg);
  }
}

/* Анимация для SVG текста */
.super-svg-text text {
  stroke-dasharray: 900; /* Для эффекта "рисования" текста */
  stroke-dashoffset: 900;
  animation: text-draw linear forwards; /* Имя keyframes изменено */
  animation-timeline: --super-scroll-tl; /* Привязка к таймлайну */
  animation-range: contain 0% contain 100%; /* Диапазон изменен */
  /* ... другие стили для .super-svg-text text из файла super-scroll.css ... */
}

@keyframes text-draw { /* Новые keyframes для текста */
  0% {
    stroke-dashoffset: 900;
  }
  100% {
    stroke-dashoffset: 0;
  }
}</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите страницу вниз, чтобы увидеть анимацию SVG элементов.</p>
                    <div class="example-container tall-example">
                        <section class="super-scroll">
                            <div class="super-svg">
                                <svg viewBox="0 0 100 100" class="super-svg-1"><circle cx="50" cy="50" r="40" /></svg>
                                <svg viewBox="0 0 800 120" class="super-svg-text" width="60vw" height="120">
                                    <defs>
                                        <linearGradient id="superTextGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" stop-color="#3a86ff" stop-opacity="0.8"/>
                                            <stop offset="60%" stop-color="#8338ec" stop-opacity="0.8"/>
                                            <stop offset="100%" stop-color="#fff" stop-opacity="0.7"/>
                                        </linearGradient>
                                    </defs>
                                    <text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle" font-size="64" font-family="'Montserrat', Arial, sans-serif" fill="none" stroke="url(#superTextGradient)" stroke-width="3" stroke-linecap="round">Scroll-Driven Animation</text>
                                </svg>
                                <svg viewBox="0 0 100 100" class="super-svg-2"><rect x="10" y="10" width="80" height="80" rx="10"/></svg>
                            </div>
                        </section>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section: Page Scroll Progress Bar -->
        <section id="progress-bar" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Индикатор прогресса страницы</h2>
                <p>Создание индикатора, показывающего прогресс прокрутки всей страницы.</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Для индикатора прогресса нам нужен всего один простой элемент <code>&lt;div&gt;</code>, который будет позиционирован вверху страницы. Этот элемент должен быть прямым потомком <code>&lt;body&gt;</code> для корректной работы с <code>scroll(root block)</code>.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;body&gt;
  &lt;div class="page-progress-bar"&gt;&lt;/div&gt;
  
  &lt;!-- Остальное содержимое страницы: сайдбар, хедер, контент --&gt;
  &lt;aside class="sidebar"&gt;...&lt;/aside&gt;
  &lt;header class="header"&gt;...&lt;/header&gt;
  &lt;main class="content-wrapper"&gt;...&lt;/main&gt;
&lt;/body&gt;</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>CSS Анимация</h3>
                    <p class="paragraf">Ключевые моменты в CSS: фиксированное позиционирование (<code>position: fixed</code>) вверху экрана, начальная ширина 0% и анимация, привязанная к временной шкале прокрутки всего документа (<code>animation-timeline: scroll(root block)</code>). Анимация <code>fill-progress</code> изменяет свойство <code>width</code> элемента от 0% до 100% по мере прокрутки пользователем содержимого страницы.</p>
                    <div class="code-block">
                        <pre><code class="language-css">.page-progress-bar {
  position: fixed; /* Фиксированное позиционирование относительно вьюпорта */
  top: 0; /* Вверху экрана */
  left: 0; /* Слева экрана */
  width: 0%; /* Начальная ширина 0% */
  height: 5px; /* Высота индикатора */
  background-color: var(--accent-primary); /* Цвет из CSS переменных темы */
  z-index: 1000; /* Убеждаемся, что индикатор поверх другого контента */
  
  /* Начальное состояние для плавного появления при переключении вкладок */
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.3s ease, visibility 0s ease 0.3s;

  /* Применяем анимацию заполнения */
  animation: fill-progress linear forwards;
  /* 'forwards' удерживает конечное состояние анимации (width: 100%) */
  
  /* Привязываем анимацию к прокрутке всего документа по вертикальной оси */
  animation-timeline: scroll(root block); 
}

/* Класс для отображения прогресс-бара, когда активна соответствующая вкладка */
.page-progress-bar.progress-bar-active-on-tab {
  visibility: visible;
  opacity: 1;
  transition: opacity 0.3s ease, visibility 0s ease 0s; /* Плавное появление */
}

@keyframes fill-progress {
  from {
    width: 0%; /* Анимация начинается с ширины 0% */
  }
  to {
    width: 100%; /* Анимация заканчивается шириной 100% */
  }
}</code></pre>
                    </div>
                    <p class="paragraf"><code>scroll(root block)</code> указывает, что временная шкала анимации определяется прокруткой корневого элемента документа (обычно <code>&lt;html&gt;</code>) по его блочной (вертикальной) оси.</p>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите эту страницу вверх и вниз, чтобы увидеть, как индикатор прогресса в самой верхней части окна браузера заполняется. Для наглядности ниже добавлен блок с большой высотой, чтобы обеспечить достаточную область для прокрутки.</p>
                    <div class="example-container" style="height: 150vh; background-color: var(--bg-tertiary); padding: 2rem; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
                        <p style="font-size: 1.5rem; color: var(--text-secondary); margin-bottom: 1rem;">Прокручивайте эту область, чтобы увидеть эффект индикатора прогресса страницы.</p>
                        <p style="font-size: 1rem; color: var(--text-tertiary);">Чем больше вы прокручиваете, тем больше заполняется полоса вверху экрана.</p>
                        <div style="margin-top: 2rem; font-size: 5rem; opacity: 0.2;"><i class="fas fa-arrow-down"></i></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 6: Polyfill and Limitations -->
        <section id="polyfill" class="content-section">
            <div class="section-header">
                <h2>Polyfill, поддержка браузерами и производительность</h2>
                <p>Информация о polyfill для Scroll-Driven Animations, его работе, ограничениях, поддержке в браузерах, вопросах производительности и интеграции с NextJS.</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>Поддержка браузерами и Polyfill</h3>
                    <p class="paragraf">CSS scroll-driven animations - относительно новая технология. В Firefox её нужно включать вручную (флаг <code>layout.css.scroll-driven-animations.enabled</code> в <code>about:config</code>), а Safari долгое время не поддерживал нативно и требует polyfill.</p>
                    <p class="paragraf">Для улучшения кроссбраузерности можно использовать polyfill:</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;!-- Подключение polyfill --&gt;
&lt;script src="https://flackr.github.io/scroll-timeline/dist/scroll-timeline.js"&gt;&lt;/script&gt;</code></pre>
                    </div>
                    <p class="paragraf">К сожалению, данный метод создания анимаций имеет свои недостатки. В частности, в браузере Firefox требуется отдельное включение этой функции в настройках CSS. Safari не поддерживает указанные свойства. Есть полифилл, который поможет решить проблему совместимости, однако у него есть свои ограничения. Отсутствие документации затрудняет работу, поскольку информация о возможных проблемах может быть доступна только в процессе разработки или в разделе проблем на GitHub.</p>
                </div>

                <div class="docs-block">
                    <h3>Как работает Polyfill?</h3>
                    <p class="paragraf">Подключение осуществляется путем добавления JavaScript-скрипта на вашу страницу. Скрипт можно скачать или подключить через ссылку. Все свойства анимации, связанные с <code>animation-timeline</code>, извлекаются из CSS и переопределяются с помощью JavaScript в соответствии с требованиями, описанными в спецификации для этих свойств: <a href="https://drafts.csswg.org/scroll-animations-1/" target="_blank" rel="noopener noreferrer">W3C Scroll Animations Level 1</a>.</p>
                    <p class="paragraf">Полифил сканирует CSS правила и переопределяет свойства, связанные с animation-timeline, используя JavaScript.</p>
                    <img class="img image-center" src="/src/img/polyfill/1.png" alt="CSS Parsing Concept">
                    <img class="img image-center" src="/src/img/polyfill/2.png" alt="Script Tag Example">
                </div>

                <div class="docs-block">
                    <h3>Ограничения Polyfill</h3>
                    <p class="paragraf"><strong>Проблема с подключением CSS файлов по ссылкам асинхронно:</strong> Так как полифил получает CSS при загрузке. И если он загрузится до загрузки CSS загружаемых асинхронно, то он не сможет их спарсить.</p>
                    <p class="paragraf"><strong>Проблема с подключением этого полифилла асинхронно:</strong> Так как изначально у нас существует временная шкала документа, которая обычно и используется при анимациях, то при загрузке документа эти анимации сразу начинают выполнятся. А полифилл работает таким образом, что он ловит анимации перед тем, как они исполнятся. И не успевая загрузиться все анимации уже "сыграли" и он не может их обработать.</p>
                    <p class="paragraf">Существует проблема при подключении CSS-файлов асинхронно. Полифилл получает CSS во время загрузки страницы, и если он загружается до того, как асинхронно загружаемые CSS-файлы будут доступны, полифилл не сможет их корректно обработать.</p>
                    <p class="paragraf">Также возникают трудности при асинхронной загрузке самого полифилла. Поскольку на момент загрузки документа уже существует временная шкала, используемая для анимаций, анимации начинают выполняться сразу. Полифилл перехватывает анимации до их выполнения, но если он не успевает загрузиться во время, анимации уже могут завершиться, и полифилл не сможет их корректно обработать.</p>
                    <img class="img image-center" src="/src/img/polyfill/3.png" alt="Async Loading Issue">
                    <p class="paragraf"><strong>Попытки решения проблемы с асинхронной загрузкой:</strong> Чтобы анимация не закончилась до загрузки нужно отображать компоненты или добавлять стили с анимацией только после загрузки самого полифила.</p>
                    <p class="paragraf">Дополнительные ограничения из оригинального файла:</p>
                    <ul class="ul">
                        <li class="li"><strong>Отсутствие документации:</strong> Многие нюансы выясняются только на практике.</li>
                        <li class="li"><strong>Производительность:</strong> JavaScript-эмуляция может быть менее эффективной.</li>
                    </ul>
                    <p class="paragraf">Несмотря на ограничения, polyfill позволяет использовать scroll-driven animations во всех современных браузерах.</p>
                </div>

                <div class="docs-block">
                    <h3>Работа с NextJS и Polyfill</h3>
                    <h4>Проблемы работы с NextJS:</h4>
                    <p class="paragraf">Работа с nextJS. Все тесты проводились на nextJS версии 14.2.5, app router. Был подключен полифил в layout с помощью ссылки на скрипт, из документации к полифилу. Далее тестируем разные анимации: Я взял 4 эффекта, это carousel, horizontal scroll, progress и reveal.</p>
                    <p class="paragraf"><strong>Результаты (Chrome Desktop):</strong> Все 4 эффекта отлично работают на компьютере в браузере chrome.</p>
                    <p class="paragraf"><strong>Результаты (Chrome Mobile):</strong> На телефоне в chrome работают horizontal scroll, progress, reveal.</p>
                    <p class="paragraf"><strong>Результаты (BrowserStack Safari 17.3):</strong> В browserStack на safari 17.3 работают carousel, horizontal scroll (есть баг), progress и reveal.</p>
                    <p class="paragraf">Тестирование на версии "next": "^13.5.2" page router. Подключение полифила аналогичное.</p>
                    <p class="paragraf"><strong>Результаты (Chrome Desktop):</strong> Все 4 эффекта отлично работают на компьютере в браузере chrome.</p>
                    <p class="paragraf"><strong>Результаты (Chrome Mobile):</strong> На телефоне в chrome работают horizontal scroll, progress, reveal.</p>
                    <p class="paragraf"><strong>Результаты (BrowserStack Safari 17.3):</strong> В browserStack на safari 17.3 работают carousel, horizontal scroll (есть баг), progress и reveal.</p>
                    <p class="paragraf">Также был проверен firefox 127 все отлично работает.</p>
                </div>
            </div>
        </section>

        <!-- Section 7: Card Stack Animation -->
        <section id="card-stack" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Эффект "Стопка Карточек" при скролле</h2>
                <p>Создание анимации, где карточки последовательно "налипают" друг на друга при прокрутке.</p>
            </div>
            <div class="section-body">

                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Структура состоит из общего контейнера (<code>.card-stack-example-area</code>), который обеспечивает необходимую высоту для прокрутки, и самих карточек (<code>.card-stack-card</code>), каждая из которых будет анимироваться и "прилипать".</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;div class="card-stack-example-area"&gt;
  &lt;div class="card-stack-card card-1"&gt;
    &lt;h4&gt;Карточка 1&lt;/h4&gt;
    &lt;p&gt;Содержимое первой карточки...&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="card-stack-card card-2"&gt;
    &lt;h4&gt;Карточка 2&lt;/h4&gt;
    &lt;p&gt;Содержимое второй карточки...&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="card-stack-card card-3"&gt;
    &lt;h4&gt;Карточка 3&lt;/h4&gt;
    &lt;p&gt;Содержимое третьей карточки...&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="card-stack-card card-4"&gt;
    &lt;h4&gt;Карточка 4&lt;/h4&gt;
    &lt;p&gt;Содержимое четвертой карточки...&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>CSS Реализация</h3>
                    <p class="paragraf">Ключевые CSS свойства для этого эффекта:</p>
                    <ul class="ul">
                        <li class="li"><code>position: sticky;</code> для каждой карточки, чтобы она "залипала" при достижении определенной позиции скролла.</li>
                        <li class="li">Различные значения <code>top</code> для каждой карточки, чтобы они располагались стопкой.</li>
                        <li class="li"><code>animation-timeline: view();</code> для запуска анимации появления карточки, когда она входит в область видимости.</li>
                        <li class="li"><code>animation-range</code> для тонкой настройки момента начала и конца анимации появления.</li>
                        <li class="li"><code>transform</code> и <code>opacity</code> в кейфреймах для плавного появления и масштабирования.</li>
                    </ul>
                    <p class="paragraf">Каждая карточка имеет свою анимацию входа (<code>card-entry</code>), которая срабатывает, когда карточка появляется во вьюпорте. За счет <code>position: sticky</code> и немного отличающихся значений <code>top</code>, карточки фиксируются одна за другой, создавая эффект стопки. Контейнер <code>.card-stack-example-area</code> должен иметь достаточную высоту (например, <code>350vh</code>), чтобы обеспечить пространство для прокрутки и работы sticky-эффекта для всех карточек.</p>
                    <div class="code-block">
                        <pre><code class="language-css">.card-stack-example-area {
  height: 350vh; /* Высота для обеспечения скролла */
  position: relative;
  padding-top: 5vh;
  margin-bottom: 10vh;
}

.card-stack-card {
  height: 70vh;
  width: 70%;
  max-width: 500px;
  margin: 0 auto 15vh auto; /* Отступ снизу для эффекта "наезда" */
  background: var(--bg-elevated, var(--bg-secondary));
  border: 1px solid var(--border-color);
  border-radius: 15px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column; 
  align-items: center;
  justify-content: center;
  text-align: center; 
  padding: 25px; 
  font-size: 1rem; 
  color: var(--text-primary);
  position: sticky;
  will-change: transform, opacity;
  opacity: 0;
  transform: scale(0.9) translateY(30px);
  animation: card-entry linear forwards;
  animation-timeline: view();
  animation-range: entry 10% entry 40%;
}

.card-stack-card:last-child {
  margin-bottom: 0;
}

.card-stack-card h4 {
  margin: 0 0 10px 0;
  font-size: 1.8em; 
  color: var(--accent-primary);
  font-weight: 600;
}
.card-stack-card p {
  font-size: 1em; 
  color: var(--text-secondary);
  margin-top: 0;
  line-height: 1.6;
}

/* Разные 'top' для эффекта стопки */
.card-stack-card.card-1 { top: 10vh; }
.card-stack-card.card-2 { top: 13vh; }
.card-stack-card.card-3 { top: 16vh; }
.card-stack-card.card-4 { top: 19vh; }

@keyframes card-entry {
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите вниз, чтобы увидеть, как карточки последовательно появляются и "налипают" друг на друга.</p>
                    <div class="example-container"> 
                        <div class="card-stack-example-area">
                            <div class="card-stack-card card-1">
                                <h4>Карточка 1</h4>
                                <p>Это первая карточка в нашей стопке. Она появляется плавно при скролле.</p>
                            </div>
                            <div class="card-stack-card card-2">
                                <h4>Карточка 2</h4>
                                <p>Вторая карточка наезжает и фиксируется чуть ниже первой, создавая эффект стека.</p>
                            </div>
                            <div class="card-stack-card card-3">
                                <h4>Карточка 3</h4>
                                <p>Третья карточка продолжает формирование стопки, прилипая к предыдущим.</p>
                            </div>
                            <div class="card-stack-card card-4">
                                <h4>Карточка 4</h4>
                                <p>Последняя карточка завершает эффект. Прокрутите дальше, чтобы увидеть, как они остаются "налипшими".</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="cascading-text" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Каскадное появление строк текста</h2>
                <p>Эффект, где строки текста последовательно появляются с анимацией при прокрутке.</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>Описание эффекта</h3>
                    <p class="paragraf">Этот эффект создает ощущение каскадного появления строк текста: каждая строка плавно анимируется при попадании в область видимости во время прокрутки. Традиционно для такой динамической анимации текста часто прибегают к JavaScript-библиотекам, но современные CSS Scroll-Driven Animations позволяют реализовать это элегантно и производительно без дополнительного скриптинга.</p>
                    <p class="paragraf">Каждая строка текста получает собственную временную шкалу просмотра (<code>animation-timeline: view()</code>) и анимируется в определенном диапазоне видимости (<code>animation-range</code>). Это позволяет тексту "оживать" по мере его появления на экране.</p>
                </div>

                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Структура HTML довольно проста: нужен общий контейнер для области демонстрации (<code>.cascading-text-area</code>), внутри него — контейнер для самих строк текста (<code>.cascading-text-container</code>), и затем каждая строка текста оборачивается в свой элемент (например, <code>&lt;p class="cascading-text-line"&gt;</code>).</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;div class="cascading-text-area"&gt;
  &lt;div class="cascading-text-container"&gt;
    &lt;p class="cascading-text-line"&gt;Прокрутка вниз оживляет строки,&lt;/p&gt;
    &lt;p class="cascading-text-line"&gt;Словно каскад, они всплывают,&lt;/p&gt;
    &lt;p class="cascading-text-line"&gt;CSS магией своей играют,&lt;/p&gt;
    &lt;p class="cascading-text-line"&gt;Без JavaScript мир открывают.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>CSS Реализация</h3>
                    <p class="paragraf">Ключевые моменты CSS-реализации:</p>
                    <ul class="ul">
                        <li class="li"><code>.cascading-text-line</code>: К этому классу применяется основная анимация. Изначально строки смещены за пределы экрана (<code>transform: translateX(-100px)</code>) и полностью прозрачны (<code>opacity: 0</code>).</li>
                        <li class="li"><code>animation: cascade-in linear forwards;</code>: Применяет анимацию <code>cascade-in</code>.</li>
                        <li class="li"><code>animation-timeline: view();</code>: Самое важное — каждая строка получает свою независимую временную шкалу, привязанную к её появлению во вьюпорте.</li>
                        <li class="li"><code>animation-range: entry 0% contain 50%;</code>: Анимация для каждой строки начинается, как только она начинает появляться в области видимости (<code>entry 0%</code>), и полностью завершается, когда 50% элемента находится в видимой зоне (<code>contain 50%</code>). Это создает эффект последовательного появления при скролле.</li>
                        <li class="li"><code>@keyframes cascade-in</code>: Определяет плавный переход от начального состояния (за экраном, повернуто) к финальному (на своем месте, без поворота и полностью видимо). Промежуточный шаг на 60% добавляет анимации немного "упругости".</li>
                    </ul>
                    <div class="code-block">
                        <pre><code class="language-css">
.cascading-text-area {
  padding: 10vh 2rem;
  background-color: var(--bg-tertiary);
  color: var(--text-primary);
  font-family: 'Georgia', serif;
}

.cascading-text-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.cascading-text-line {
  font-size: clamp(1.5rem, 4vw, 3rem);
  line-height: 1.4;
  text-align: center;
  opacity: 0;
  transform: translateX(-100px) rotate(-5deg);
  animation: cascade-in linear forwards;
  animation-timeline: view();
  animation-range: entry 0% contain 50%;
}

@keyframes cascade-in {
  0% {
    opacity: 0;
    transform: translateX(-100px) rotate(-5deg);
  }
  60% {
    opacity: 0.8;
    transform: translateX(10px) rotate(2deg);
  }
  100% {
    opacity: 1;
    transform: translateX(0) rotate(0deg);
  }
}</code></pre>
                    </div>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите страницу вниз, чтобы увидеть, как строки текста плавно появляются одна за другой.</p>
                    <div class="example-container" style="padding:0; margin: 0; max-width: none;">
                        <div class="cascading-text-area">
                            <div class="cascading-text-container">
                                <p class="cascading-text-line">Прокрутка вниз оживляет строки,</p>
                                <p class="cascading-text-line">Словно каскад, они всплывают,</p>
                                <p class="cascading-text-line">CSS магией своей играют,</p>
                                <p class="cascading-text-line">Без JavaScript мир открывают.</p>
                                <p class="cascading-text-line" style="margin-top: 2em; font-size: clamp(1.2rem, 3vw, 2rem); opacity:0; transform: translateY(50px);">И еще немного текста для демонстрации,</p>
                                <p class="cascading-text-line" style="font-size: clamp(1.2rem, 3vw, 2rem); opacity:0; transform: translateY(50px);">Чтобы эффект был нагляднее.</p>
                                <p class="cascading-text-line" style="font-size: clamp(1.2rem, 3vw, 2rem); opacity:0; transform: translateY(50px);">Каждая строка ждет своего часа.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="scaling-images" class="content-section recipe-example-section">
            <div class="section-header">
                <h2>Масштабирование изображений при скролле</h2>
                <p>Эффект плавного появления и масштабирования фонового изображения элемента при прокрутке.</p>
            </div>
            <div class="section-body">
                <div class="docs-block">
                    <h3>Описание эффекта</h3>
                    <p class="paragraf">Этот эффект сочетает анимацию появления (opacity и transform) с анимацией масштабирования фонового изображения. Когда элемент входит в область видимости, он плавно появляется, и одновременно его фоновое изображение увеличивается от большего размера к своему естественному, создавая эффект "приближения" или "фокусировки".</p>
                    <p class="paragraf">Используется <code>animation-timeline: view()</code>, чтобы привязать анимации к моменту попадания элемента в область видимости. <code>animation-range</code> позволяет точно настроить, на каком этапе видимости элемента должны проигрываться анимации.</p>
                </div>

                <div class="docs-block">
                    <h3>HTML Структура</h3>
                    <p class="paragraf">Для каждого элемента с эффектом масштабирования используется обертка (<code>.wrapper</code>), которая будет содержать внутренний блок (<code>.root</code>). Внутренний блок отвечает за отображение фонового изображения и анимацию его масштабирования, а также за анимацию общего появления.</p>
                    <div class="code-block">
                        <pre><code class="language-html">&lt;!-- Элемент для демонстрации эффекта --&gt;
&lt;div class="wrapper" style="background-image: url('./src/img/reveal/1.jpg');"&gt;
  &lt;div class="root"&gt;
    &lt;!-- Сюда можно поместить дополнительный контент, если необходимо --&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;!-- Еще один элемент --&gt;
&lt;div class="wrapper" style="background-image: url('./src/img/parallax/1.jpg');"&gt;
  &lt;div class="root"&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
                    </div>
                    <p class="paragraf">Обратите внимание, что URL фонового изображения задается через инлайн-стиль для удобства в примере. В реальном проекте это можно делать через CSS классы или JavaScript.</p>
                </div>

                <div class="docs-block">
                    <h3>CSS Реализация</h3>
                    <p class="paragraf">Ключевые моменты в CSS (из файла <code>src/styles/allStyle/scaling-images.css</code>):</p>
                    <ul class="ul">
                        <li class="li"><code>.wrapper</code>: Определяет размеры, соотношение сторон и является контейнером, к которому привязана анимация масштабирования фона (<code>scale-bg</code>). Использует <code>overflow: hidden;</code> чтобы обрезать фон, выходящий за пределы при масштабировании.</li>
                        <li class="li"><code>.root</code>: К этому элементу применяется анимация появления (<code>reveal</code>). Он занимает все пространство родителя.</li>
                        <li class="li"><code>@keyframes reveal</code>: Анимирует <code>opacity</code> и <code>transform: translateY/scale</code> для плавного появления содержимого.</li>
                        <li class="li"><code>@keyframes scale-bg</code>: Анимирует <code>background-size</code> для эффекта масштабирования фонового изображения на <code>.wrapper</code>.</li>
                        <li class="li"><code>animation-timeline: view()</code> и <code>animation-range</code>: Используются для обеих анимаций, чтобы они срабатывали синхронно с прокруткой и видимостью элемента.</li>
                    </ul>
                    <div class="code-block">
                        <pre><code class="language-css">/* CSS из файла src/styles/allStyle/scaling-images.css */
.wrapper {
  width: 46vw; 
  aspect-ratio: 628/866; 
  background-position: center;
  background-repeat: no-repeat;
  background-size: 120%; /* Начальный размер фона */
  animation: scale-bg linear both; 
  animation-timeline: view(); 
  animation-range: cover 0% cover 100%; 
  margin: 0 auto 3rem auto; 
  overflow: hidden; 
  border-radius: 10px; 
  box-shadow: var(--shadow-elevation);
}

.root {
  height: 100%;
  width: 100%;
  animation: reveal linear both;
  animation-timeline: view();
  animation-range: entry 0% cover 30%; 
  position: relative; 
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

@keyframes reveal {
  from {
    opacity: 0;
    transform: translateY(30px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

@keyframes scale-bg {
  from {
    background-size: 120%;
  }
  to {
    background-size: 100%;
  }
}

/* Медиа-запрос для адаптивности */
@media (max-width: 767px) {
  .wrapper {
    width: 85vw; 
  }
}

/* Стиль для .wrapper h4 был удален, так как h4 убраны из демо */
</code></pre>
                    </div>
                     <p class="paragraf">Классы <code>.scaling-image-animated-content</code> и <code>.scaling-image-viewport</code> из предыдущего примера в HTML были заменены на <code>.root</code> и <code>.wrapper</code> соответственно, чтобы соответствовать именам классов в файле <code>scaling-images.css</code>.</p>
                </div>

                <div class="docs-block">
                    <h3>Демонстрация</h3>
                    <p class="paragraf">Прокрутите вниз, чтобы увидеть, как изображения плавно появляются и их фон масштабируется.</p>
                    <div class="example-container" style="display: flex; flex-direction: column; align-items: center; gap: 3rem;">
                        <div class="img-wrapper" style="background-image: url('./src/img/reveal/1.jpg');">
                            <div class="root">
                                <!-- Removed H4 -->
                            </div>
                        </div>
                        <div class="img-wrapper" style="background-image: url('./src/img/parallax/1.jpg');">
                            <div class="root">
                                <!-- Removed H4 -->
                            </div>
                        </div>
                        <div class="img-wrapper" style="background-image: url('./src/img/reveal/2.jpg');">
                            <div class="root">
                                <!-- Removed H4 -->
                            </div>
                        </div>
                         <div class="img-wrapper" style="background-image: url('./src/img/parallax/2.jpg');">
                            <div class="root">
                                <!-- Removed H4 -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <script src="./src/js/tabs.js" type="module"></script>
    <script src="https://flackr.github.io/scroll-timeline/dist/scroll-timeline.js"></script>
</body>
</html>
